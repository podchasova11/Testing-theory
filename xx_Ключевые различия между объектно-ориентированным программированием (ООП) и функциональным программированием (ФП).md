Ключевые различия между объектно-ориентированным программированием (ООП) и функциональным программированием (ФП) можно рассмотреть по нескольким направлениям:

## 1. Основная идея и парадигма
- **ООП**: моделирование мира через объекты, которые объединяют данные (состояние) и поведение (методы). Основной единицей является объект.
  - Основные принципы: **инкапсуляция**, **наследование**, **полиморфизм**.
- **ФП**: вычисления представляются как последовательность функций, преобразующих данные. Основной единицей — чистая функция.
  - Характеристики: **чистые функции** (не имеют побочных эффектов), **функции высшего порядка**, **математическое моделирование процессов**.

## 2. Изменяемость состояния
- **ООП**: состояние объектов может изменяться через методы. Объекты держат состояние, которое можно менять со временем.
- **ФП**: по возможности избегает изменения состояния. Предпочтение отдается **неизменяемым данным** и созданию новых значений вместо модификации существующих.

## 3. Побочные эффекты
- **ООП**: побочные эффекты обычны, методы могут менять состояние объектов, взаимодействовать с внешней средой.
- **ФП**: стремление к отсутствию побочных эффектов. Чистая функция — одна и та же входная сумма → одна и та же выдача без влияния на внешнее состояние.

## 4. Модульность и композиция
- **ООП**: модулярность достигается через классы и объекты, а также через композицию объектов и агрегацию/ассоциацию.
- **ФП**: модулярность и повторное использование достигаются через композицию функций, карринг, частичное применение, высшие порядки функции.

## 5. Наследование и полиморфизм vs. абстракции и композиция
- **ООП**: чаще используется наследование для повторного использования кода и полиморфизм для замены реализации.
- **ФП**: чаще применяются абстракции через Algebraic Data Types (ADT), шаблоны и композицию функций; избегают жесткого наследования.

## 6. Примеры языков
- **ООП**: Java, C++, C#, Python (модульная поддержка ООП), Ruby, Kotlin.
- **ФП**: Haskell, Erlang, Clojure, F#, Scala (мультпарадигменный, поддерживает обе), OCaml, Rust (частично через владение иimmutability).

## 7. Гарантии и параллелизм
- **ООП**: параллелизм возможен, но управление состоянием требует внимания к потокобезопасности (мьютексы, синхронизация).
- **ФП**: благодаря неизменяемости и чистым функциям часто легче достигать безопасного параллелизма и конвейеров обработки данных.

## 8. Примеры сценариев
- **ООП**: моделирование объектов реального мира (клиенты, заказы, банковские счета) с состоянием и поведением.
- **ФП**: обработка коллекций данных (например, картирование, фильтрация, свёртка), обработка потоков данных через конвейеры функций.

---

### Табличное сравнение (кратко)

- **Основная идея**: ООП — объекты с состоянием; ФП — функции без побочных эффектов.
- **Изменяемость**: ООП допускает изменение состояния; ФП — предпочтительно неизменяемость.
- **Побочные эффекты**: ООП часто содержит их; ФП — минимизация/отсутствие.
- **Структура кода**: ООП — классы и объекты; ФП — функции и композиция функций.
- **Повторное использование**: ООП — через наследование и композицию объектов; ФП — через композицию функций и типы данных.
- **Параллелизм**: ФП обычно упрощает параллельную обработку; ООП требует осторожности с синхронизацией.

---


