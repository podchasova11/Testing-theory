Тестировщик бекенда в среде **Big Data** выполняет важную роль, особенно когда речь идёт о функциональном тестировании, включая тестирование SQL-запросов. Они отвечают за проверку правильности работы систем, обрабатывающих большие объёмы данных, и за то, чтобы данные соответствовали требованиям бизнеса. Давай рассмотрим основные аспекты функционального тестирования SQL с примерами.

### Основные задачи функционального тестирования SQL

1. **Проверка корректности запросов**:
   - Убедитесь, что SQL-запросы возвращают ожидаемые результаты.

2. **Тестирование условий и фильтров**:
   - Проверка, что WHERE, JOIN, GROUP BY и аналогичные конструкции работают правильно.

3. **Проверка статистики данных**:
   - Убедиться, что агрегированные данные (например, сумма, среднее) возвращают ожидаемые результаты.

4. **Проверка целостности данных**:
   - Проверка ограничений, таких как уникальность и взаимоотношения между таблицами.

5. **Тестирование производительности запросов**:
   - Оценка времени выполнения SQL-запросов на больших объёмах данных.

### Примеры функционального тестирования SQL

#### 1. Проверка корректности простого запроса

**Задача**: Проверить, возвращает ли запрос правильное количество записей.

```sql
SELECT COUNT(*) FROM users WHERE status = 'active';
```

**Тест**: Убедитесь, что количество активных пользователей соответствует данным в таблице.

**Ожидаемый результат**: Если в таблице 100 активных пользователей, то запрос должен вернуть 100.

#### 2. Тестирование условий и фильтров

**Задача**: Проверить, корректно ли работает фильтрация по дате.

```sql
SELECT * FROM orders WHERE order_date >= '2025-01-01' AND order_date < '2025-04-01';
```

**Тест**: Убедитесь, что выбранные записи действительно находятся в пределах указанных дат.

**Ожидаемый результат**: Если в выбранном диапазоне дат есть 50 заказов, запрос должен вернуть 50 записей.

#### 3. Проверка агрегации данных

**Задача**: Проверить правильность суммирования продаж по категориям.

```sql
SELECT category, SUM(sales) AS total_sales 
FROM products 
GROUP BY category;
```

**Тест**: Убедитесь, что сумма продаж по категориям соответствует данным в таблице.

**Ожидаемый результат**: Для каждой категории должна быть правильная сумма продаж.

#### 4. Проверка целостности данных

**Задача**: Проверка уникальности email адресов.

```sql
SELECT email, COUNT(*) 
FROM users 
GROUP BY email 
HAVING COUNT(*) > 1;
```

**Тест**: Убедитесь, что результат пустой (т.е. в таблице нет дублирующихся email).

**Ожидаемый результат**: Если запрос возвращает строки, это указывает на проблему с уникальностью.

#### 5. Тестирование производительности

**Задача**: Измерение времени выполнения сложного запроса.

```sql
SELECT p.product_name, SUM(o.quantity) AS total_sold 
FROM products p 
JOIN orders o ON p.id = o.product_id 
GROUP BY p.product_name 
ORDER BY total_sold DESC 
LIMIT 10;
```

**Тест**: Запустите запрос и измерьте время его выполнения.

**Ожидаемый результат**: Запрос должен выполняться в пределах заданного времени (например, менее 5 секунд на объёме данных в 1 миллион записей).

### Заключение

Функциональное тестирование SQL в среде Big Data помогает обеспечить правильность и целостность данных, что критично для анализа и принятия бизнес-решений. Тестировщик бекенда должен не только проверять корректность запросов, но и анализировать производительность, целостность и соответствие бизнес-требованиям.


______________________________________________________________________________________

## больше задач по SQL для платформы агрегатора МТС все страховки insurance.mts.ru
Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. 
Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. 
_________________________________________

