Тестировщик бекенда в среде **Big Data** выполняет важную роль, особенно когда речь идёт о функциональном тестировании, включая тестирование SQL-запросов. Они отвечают за проверку правильности работы систем, обрабатывающих большие объёмы данных, и за то, чтобы данные соответствовали требованиям бизнеса. Давай рассмотрим основные аспекты функционального тестирования SQL с примерами.

### Основные задачи функционального тестирования SQL

1. **Проверка корректности запросов**:
   - Убедитесь, что SQL-запросы возвращают ожидаемые результаты.

2. **Тестирование условий и фильтров**:
   - Проверка, что WHERE, JOIN, GROUP BY и аналогичные конструкции работают правильно.

3. **Проверка статистики данных**:
   - Убедиться, что агрегированные данные (например, сумма, среднее) возвращают ожидаемые результаты.

4. **Проверка целостности данных**:
   - Проверка ограничений, таких как уникальность и взаимоотношения между таблицами.

5. **Тестирование производительности запросов**:
   - Оценка времени выполнения SQL-запросов на больших объёмах данных.

### Примеры функционального тестирования SQL

#### 1. Проверка корректности простого запроса

**Задача**: Проверить, возвращает ли запрос правильное количество записей.

```sql
SELECT COUNT(*) FROM users WHERE status = 'active';
```

**Тест**: Убедитесь, что количество активных пользователей соответствует данным в таблице.

**Ожидаемый результат**: Если в таблице 100 активных пользователей, то запрос должен вернуть 100.

#### 2. Тестирование условий и фильтров

**Задача**: Проверить, корректно ли работает фильтрация по дате.

```sql
SELECT * FROM orders WHERE order_date >= '2025-01-01' AND order_date < '2025-04-01';
```

**Тест**: Убедитесь, что выбранные записи действительно находятся в пределах указанных дат.

**Ожидаемый результат**: Если в выбранном диапазоне дат есть 50 заказов, запрос должен вернуть 50 записей.

#### 3. Проверка агрегации данных

**Задача**: Проверить правильность суммирования продаж по категориям.

```sql
SELECT category, SUM(sales) AS total_sales 
FROM products 
GROUP BY category;
```

**Тест**: Убедитесь, что сумма продаж по категориям соответствует данным в таблице.

**Ожидаемый результат**: Для каждой категории должна быть правильная сумма продаж.

#### 4. Проверка целостности данных

**Задача**: Проверка уникальности email адресов.

```sql
SELECT email, COUNT(*) 
FROM users 
GROUP BY email 
HAVING COUNT(*) > 1;
```

**Тест**: Убедитесь, что результат пустой (т.е. в таблице нет дублирующихся email).

**Ожидаемый результат**: Если запрос возвращает строки, это указывает на проблему с уникальностью.

#### 5. Тестирование производительности

**Задача**: Измерение времени выполнения сложного запроса.

```sql
SELECT p.product_name, SUM(o.quantity) AS total_sold 
FROM products p 
JOIN orders o ON p.id = o.product_id 
GROUP BY p.product_name 
ORDER BY total_sold DESC 
LIMIT 10;
```

**Тест**: Запустите запрос и измерьте время его выполнения.

**Ожидаемый результат**: Запрос должен выполняться в пределах заданного времени (например, менее 5 секунд на объёме данных в 1 миллион записей).

### Заключение

Функциональное тестирование SQL в среде Big Data помогает обеспечить правильность и целостность данных, что критично для анализа и принятия бизнес-решений. Тестировщик бекенда должен не только проверять корректность запросов, но и анализировать производительность, целостность и соответствие бизнес-требованиям.


______________________________________________________________________________________

## больше задач по SQL для платформы агрегатора МТС все страховки insurance.mts.ru
Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. 
Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. Если вам нужны дополнительные примеры или разбор конкретных аспектов, пожалуйста, дайте знать!Конечно! Давайте рассмотрим несколько задач по SQL, которые могут быть полезны для тестирования и работы с платформой агрегатора МТС для страхования. Эти задачи охватывают различные аспекты функционального тестирования и могут помочь проверять корректность работы базы данных, а также целостность и производительность запроса.

### Примеры SQL задач для платформы агрегатора страховок МТС

#### 1. Проверка корректности данных о страховых полисах

**Задача**: Убедитесь, что все страховые полисы имеют правильный статус и даты окончания.

```sql
SELECT id, policy_number, status, end_date 
FROM insurance_policies 
WHERE status NOT IN ('active', 'expired') OR end_date < NOW();
```

**Ожидаемый результат**: Должен вернуть пустой набор. Если есть записи, это указывает на некорректные статусы или просроченные полисы.

---

#### 2. Агрегация страховых полисов по типу

**Задача**: Получить количество полисов по каждому типу страховки (автомобильная, медицинская и т.д.)

```sql
SELECT insurance_type, COUNT(*) AS policy_count  
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть список типов страховки с соответствующим количеством полисов.

---

#### 3. Проверка дубликатов клиентов

**Задача**: Найти клиентов с дублирующимися записями (например, одинаковыми именами и email-адресами).

```sql
SELECT client_name, email, COUNT(*) 
FROM clients 
GROUP BY client_name, email 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов, у которых есть дубликаты. Если результат пустой, то дубликатов нет.

---

#### 4. Расчёт средней стоимости полисов

**Задача**: Узнать среднюю стоимость полисов по типам страховки.

```sql
SELECT insurance_type, AVG(premium) AS average_premium 
FROM insurance_policies 
GROUP BY insurance_type;
```

**Ожидаемый результат**: Должен вернуть среднюю стоимость для каждого типа страховки.

---

#### 5. Поиск клиентов с несколькими полисами

**Задача**: Найти клиентов, у которых имеется более одного страхового полиса.

```sql
SELECT client_id, COUNT(*) AS policy_count 
FROM insurance_policies 
GROUP BY client_id 
HAVING COUNT(*) > 1;
```

**Ожидаемый результат**: Должен вернуть список клиентов с количеством полисов более 1.

---

#### 6. Агрегация по регионам

**Задача**: Получить количество проданных полисов по регионам.

```sql
SELECT region, COUNT(*) AS policy_count 
FROM insurance_policies 
INNER JOIN clients ON insurance_policies.client_id = clients.id 
GROUP BY region;
```

**Ожидаемый результат**: Должен вернуть количество полисов, проданных в каждом регионе.

---

#### 7. Проверка сроков действия полисов

**Задача**: Найти полисы, срок действия которых истекает в следующем месяце.

```sql
SELECT id, policy_number, end_date 
FROM insurance_policies 
WHERE end_date BETWEEN NOW() AND NOW() + INTERVAL '1 month';
```

**Ожидаемый результат**: Должен вернуть полисы, которые истекают в течение следующего месяца.

---

#### 8. Поиск страховок с высоким премиумом

**Задача**: Получить полисы с премией выше заданного значения.

```sql
SELECT * 
FROM insurance_policies 
WHERE premium > 10000; -- Замените 10000 на нужное значение
```

**Ожидаемый результат**: Должен вернуть все полисы, стоимость которых выше заданного значения.

---

#### 9. Отчет по отказам в оформлении полисов

**Задача**: Получить количество отказов по оформлению полисов.

```sql
SELECT COUNT(*) AS rejection_count 
FROM insurance_applications 
WHERE status = 'rejected';
```

**Ожидаемый результат**: Должен вернуть количество отказанных заявок на страхование.

---

#### 10. Полисы с бонусами

**Задача**: Найти полисы с бонусами, если такие существуют, и их общую стоимость.

```sql
SELECT SUM(premium) AS total_bonus_premium 
FROM insurance_policies 
WHERE bonus_applied = TRUE;
```

**Ожидаемый результат**: Должен вернуть общую стоимость полисов с применёнными бонусами.

---

### Заключение

Эти задачи по SQL помогут тестировщикам и аналитикам убедиться в правильности работы базы данных на агрегаторе страхования МТС, а также в целостности и корректности данных. 
_________________________________________
дополнительные примеры
Конечно! Вот продолжение задачи и еще больше примеров SQL-запросов для платформы агрегатора МТС для страховок.

### Дополнительные SQL задачи (продолжение)

#### 20. Продление полисов (продолжение)

**Задача**: Найти всех клиентов, которые продлили свои полисы в текущем месяце.

```sql
SELECT c.client_name, p.policy_number, p.renewal_date 
FROM insurance_policies p 
JOIN clients c ON p.client_id = c.id 
WHERE MONTH(p.renewal_date) = MONTH(CURRENT_DATE()) 
  AND YEAR(p.renewal_date) = YEAR(CURRENT_DATE());
```

**Ожидаемый результат**: Должен вернуть имена клиентов, номера полисов и даты продления для всех полисов, которые были продлены в текущем месяце.

---

#### 21. Количество заявок по месяцам

**Задача**: Построить отчет по количеству заявок на страхование, оформленных каждый месяц.

```sql
SELECT YEAR(application_date) AS year, MONTH(application_date) AS month, COUNT(*) AS application_count 
FROM insurance_applications 
GROUP BY year, month 
ORDER BY year, month;
```

**Ожидаемый результат**: Должен вернуть количество заявок на страхование, сгруппированных по месяцам.

---

#### 22. Полисы с высокими рисками

**Задача**: Получить список полисов, которые имеют высокий риск (например, приосереденные клиенты).

```sql
SELECT p.policy_number, c.client_name, p.risk_level 
FROM insurance_policies p 
JOIN clients c ON p.client_id = c.id 
WHERE p.risk_level = 'high';
```

**Ожидаемый результат**: Должен вернуть номера полисов, имена клиентов и уровень риска для полисов с высоким риском.

---

#### 23. Поиск аннулированных полисов

**Задача**: Найти полисы, которые были аннулированы.

```sql
SELECT id, policy_number, cancellation_date 
FROM insurance_policies 
WHERE status = 'canceled';
```

**Ожидаемый результат**: Должен вернуть список аннулированных полисов с датами аннулирования.

---

#### 24. Анализ доходности полисов

**Задача**: Определить полисы с наиболее доходной премией, подсчитав доходы для каждого полиса.

```sql
SELECT policy_number, SUM(premium) AS total_income 
FROM payments 
WHERE payment_status = 'completed' 
GROUP BY policy_number 
ORDER BY total_income DESC 
LIMIT 10;
```

**Ожидаемый результат**: Должен вернуть 10 полисов с наивысшими доходами.

---

#### 25. Полисы с уменьшенной стоимостью

**Задача**: Найти полисы, у которых была снижена стоимость за счёт бонусов или акций.

```sql
SELECT policy_number, premium, discount_amount 
FROM insurance_policies 
WHERE discount_amount > 0;
```

**Ожидаемый результат**: Должен вернуть полисы с действующими скидками.

---

#### 26. Частота общения с клиентами

**Задача**: Определить, сколько раз каждый клиент обращался за поддержкой.

```sql
SELECT client_id, COUNT(*) AS support_requests 
FROM support_tickets 
GROUP BY client_id;
```

**Ожидаемый результат**: Должен вернуть количество обращений за поддержкой для каждого клиента.

---

#### 27. Полисы, оформленные через онлайн

**Задача**: Получить количество полисов, оформленных через онлайн-канал.

```sql
SELECT COUNT(*) AS online_policy_count 
FROM insurance_policies 
WHERE application_source = 'online';
```

**Ожидаемый результат**: Должен вернуть общее количество полисов, оформленных через интернет.

---

#### 28. Проверка актуальности адресов клиентов

**Задача**: Найти клиентов с устаревшими адресами или без адреса.

```sql
SELECT id, client_name, address 
FROM clients 
WHERE address IS NULL OR address = '';
```

**Ожидаемый результат**: Должен вернуть список клиентов с отсутствующими или неполными адресами.

---

#### 29. Поиск клиентов с несколькими обращениями

**Задача**: Найти клиентов, которые сделали более 3 обращений за службой поддержки.

```sql
SELECT client_id, COUNT(*) AS request_count 
FROM support_tickets 
GROUP BY client_id 
HAVING request_count >
```
__________________________________________________

## несколько сложных запросов

Конечно! Давайте рассмотрим несколько более сложных SQL-запросов, которые могут быть использованы для анализа данных в контексте платформы агрегатора страховок, такой как МТС. Эти запросы будут включать сложные объединения, подзапросы, аналитические функции и оконные функции.

### Сложные SQL-запросы

#### 1. Политика и клиенты с высокими премиями и их средний возраст

**Задача**: Получить список всех полисов с премией выше 10000, а также из каких возрастных групп клиенты, оформившие эти полисы.

```sql
SELECT 
    p.policy_number,
    c.client_name,
    c.age,
    CASE 
        WHEN c.age < 25 THEN '18-24'
        WHEN c.age < 35 THEN '25-34'
        WHEN c.age < 45 THEN '35-44'
        WHEN c.age < 55 THEN '45-54'
        ELSE '55+' 
    END AS age_group
FROM 
    insurance_policies p
JOIN 
    clients c ON p.client_id = c.id
WHERE 
    p.premium > 10000;
```

**Ожидаемый результат**: Должен вернуть номера полисов, имена клиентов, их возраст и возрастную группу для всех клиентов с полисами премией выше 10000.

---

#### 2. Полисы с самым высоким доходом по типам страховок

**Задача**: Определить типы страховок с максимальным общим доходом (премии) и количеством оформленных полисов.

```sql
SELECT 
    p.insurance_type,
    COUNT(p.policy_number) AS policy_count,
    SUM(p.premium) AS total_income
FROM 
    insurance_policies p
GROUP BY 
    p.insurance_type
ORDER BY 
    total_income DESC; 
```

**Ожидаемый результат**: Должен вернуть типы страховок, общее количество полисов и их доход. 

---

#### 3. Клиенты с аннулированными полисами и причина аннулирования

**Задача**: Получить список клиентов, у которых есть аннулированные полисы и узнать причины аннулирования.

```sql
SELECT 
    c.client_name,
    p.policy_number,
    p.cancellation_reason
FROM 
    clients c
JOIN 
    insurance_policies p ON c.id = p.client_id
WHERE 
    p.status = 'canceled';
```

**Ожидаемый результат**: Должен вернуть имена клиентов, номера аннулированных полисов и причины аннулирования.

---

#### 4. Анализ временных интервалов между подачей и обработкой заявок

**Задача**: Получить среднее время между подачей заявки и её обработкой для каждой страховки.

```sql
SELECT 
    p.insurance_type,
    AVG(DATEDIFF(a.processing_date, a.application_date)) AS average_processing_time
FROM 
    insurance_applications a
JOIN 
    insurance_policies p ON a.policy_id = p.id
WHERE 
    a.status = 'approved'
GROUP BY 
    p.insurance_type;
```

**Ожидаемый результат**: Должен вернуть усредненное время обработки заявок по типам страховок.

---

#### 5. Отчёт по отказам на основе возраста и полиса

**Задача**: Проанализировать, сколько отказов на заявки на страхование было у клиентов в разных возрастных группах.

```sql
SELECT 
    CASE 
        WHEN c.age < 25 THEN '18-24'
        WHEN c.age < 35 THEN '25-34'
        WHEN c.age < 45 THEN '35-44'
        WHEN c.age < 55 THEN '45-54'
        ELSE '55+' 
    END AS age_group,
    COUNT(a.status) AS rejection_count
FROM 
    insurance_applications a
JOIN 
    clients c ON a.client_id = c.id
WHERE 
    a.status = 'rejected'
GROUP BY 
    age_group
ORDER BY 
    age_group;
```

**Ожидаемый результат**: Должен вернуть количество отказов по возрастным группам.

---

#### 6. Анализ доходности клиентов

**Задача**: Узнать общее количество премий, уплаченных клиентами, и общую задолженность по каждому из них.

```sql
SELECT 
    c.client_name,
    SUM(p.premium) AS total_paid,
    (SELECT SUM(due_amount) FROM payments WHERE client_id = c.id AND payment_status = 'overdue') AS total_due
FROM
```
--------------------------------------

SELECT A.id, A.name, B.city
FROM A
INNER JOIN B ON A.id = B.id;
 выполни для таблиц А: id | name
-----------
1  | Alice
2  | Bob
3  | Charlie
  В: id | city
-----------
1  | New York
3  | Los Angeles
4  | Chicago
Давайте выполним запрос к таблицам A и B с приведёнными данными.

### Исходные таблицы

**Таблица A:**
```
id | name
-----------
1  | Alice
2  | Bob
3  | Charlie
```

**Таблица B:**
```
id | city
-----------
1  | New York
3  | Los Angeles
4  | Chicago
```

### SQL Запрос

Запрос:
```sql
SELECT A.id, A.name, B.city
FROM A
INNER JOIN B ON A.id = B.id;
```

### Результаты выполнения запроса

Этот запрос выполняет внутреннее соединение (INNER JOIN) таблиц A и B по полю `id`. Это значит, что он вернёт только те строки, где значение `id` совпадает в обеих таблицах.

**Результат запроса:**
```
id | name    | city        
---------------------------
1  | Alice   | New York    
3  | Charlie | Los Angeles  
```

### Объяснение результатов

1. **Alice**: У неё `id = 1`, который присутствует в таблице B (с городом New York).
2. **Charlie**: У него `id = 3`, который также присутствует в таблице B (с городом Los Angeles).

**Bob** с `id = 2` и запись с `id = 4` в таблице B не совпадают, поэтому они не попадают в результаты.

Таким образом, ответ на ваш запрос — это две строки, соответствующие Alice и Charlie, вместе с их городами.
