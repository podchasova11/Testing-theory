Чувствительные данные в автотестах нужно хранить **безопасно и конфиденциально**. Вот основные подходы от самого простого к более сложным:

## 1. **Переменные окружения (Environment Variables) - Самый частый способ**

### `.env` файл (не коммитить в Git!)
```env
TEST_USERNAME=test_user
TEST_PASSWORD=super_secure_password_123
API_KEY=sk_test_abc123
DB_PASSWORD=db_pass_789
```

### `config.py` или `conftest.py`
```python
import os
from dotenv import load_dotenv

load_dotenv()  # Загружает переменные из .env

class TestConfig:
    TEST_USERNAME = os.getenv("TEST_USERNAME")
    TEST_PASSWORD = os.getenv("TEST_PASSWORD")
    API_KEY = os.getenv("API_KEY", "default_for_local")
    
    @classmethod
    def validate(cls):
        if not cls.TEST_USERNAME:
            raise ValueError("TEST_USERNAME не установлен")
```

### `.gitignore` обязательно:
```
.env
*.env
secrets/
.env.local
.env.*.local
```

## 2. **Шифрованные файлы конфигурации**

### Использование `cryptography` или `python-dotenv-vault`
```python
# pip install python-dotenv-vault
from dotenv_vault import load_dotenv
load_dotenv()  # Автоматически находит .env.vault
```

### Шифрование через CI/CD (GitHub Secrets/GitLab CI)
```yaml
# .github/workflows/tests.yml
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      TEST_PASSWORD: ${{ secrets.TEST_PASSWORD }}
      API_KEY: ${{ secrets.API_KEY }}
    steps:
      - run: python -m pytest
```

## 3. **Secret Management Services (для enterprise)**

### AWS Secrets Manager
```python
import boto3
from botocore.exceptions import ClientError

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    try:
        response = client.get_secret_value(SecretId=secret_name)
        return response['SecretString']
    except ClientError as e:
        raise e

# В тестах
@pytest.fixture(scope="session")
def db_credentials():
    secret = json.loads(get_secret("test-db-credentials"))
    return secret
```

### HashiCorp Vault
```python
import hvac

client = hvac.Client(url=os.getenv('VAULT_URL'))
client.auth.approle.login(
    role_id=os.getenv('VAULT_ROLE_ID'),
    secret_id=os.getenv('VAULT_SECRET_ID')
)

credentials = client.read('secret/data/test-credentials')
```

## 4. **Специализированные библиотеки для Python**

### `python-decouple`
```python
from decouple import config

TEST_USER = config('TEST_USER', default='test_default')
TEST_PASS = config('TEST_PASS', cast=str)
API_KEY = config('API_KEY', cast=str)
```

### `dynaconf`
```python
from dynaconf import Dynaconf

settings = Dynaconf(
    envvar_prefix="MYAPP",
    settings_files=['settings.toml', '.secrets.toml'],
)

# .secrets.toml (в .gitignore)
[default]
password = "mysecret"

# В коде
password = settings.password
```

## 5. **Локальное хранилище с мастер-паролем**

### Шифрование через ключ
```python
from cryptography.fernet import Fernet
import json

class SecretStore:
    def __init__(self, key_file=".test_key"):
        with open(key_file, "rb") as f:
            self.key = f.read()
        self.cipher = Fernet(self.key)
    
    def get_secret(self, env_name):
        encrypted = os.getenv(env_name)
        if encrypted:
            decrypted = self.cipher.decrypt(encrypted.encode())
            return decrypted.decode()
        return None

# Генерация ключа (однократно)
# from cryptography.fernet import Fernet
# key = Fernet.generate_key()
# with open(".test_key", "wb") as f: f.write(key)
```

## 6. **Паттерны для разных типов тестов**

### Для UI-тестов (Selenium/Playwright)
```python
# tests/conftest.py
import pytest
from selenium import webdriver
import os

@pytest.fixture
def auth_user():
    """Возвращает аутентифицированную сессию"""
    return {
        "username": os.getenv("UI_TEST_USER"),
        "password": os.getenv("UI_TEST_PASSWORD")
    }

@pytest.fixture
def logged_in_page(page, auth_user):
    """Page с выполненным логином"""
    page.goto("/login")
    page.fill("#username", auth_user["username"])
    page.fill("#password", auth_user["password"])
    page.click("#submit")
    yield page
```

### Для API-тестов
```python
# tests/api/conftest.py
import pytest
import requests

@pytest.fixture(scope="session")
def api_credentials():
    return {
        "client_id": os.getenv("API_CLIENT_ID"),
        "client_secret": os.getenv("API_CLIENT_SECRET"),
        "token_url": os.getenv("API_TOKEN_URL")
    }

@pytest.fixture
def auth_header(api_credentials):
    """Получает и возвращает токен"""
    resp = requests.post(
        api_credentials["token_url"],
        data={
            "client_id": api_credentials["client_id"],
            "client_secret": api_credentials["client_secret"],
            "grant_type": "client_credentials"
        }
    )
    token = resp.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

## 7. **Иерархия конфигурации (рекомендуемая)**

```python
# config/
# ├── __init__.py
# ├── settings.py
# └── secrets.py  # .gitignore

# config/settings.py
from enum import Enum

class Environment(Enum):
    LOCAL = "local"
    CI = "ci"
    STAGING = "staging"
    PROD = "prod"

# config/secrets.py
import os
from functools import lru_cache

@lru_cache()
def get_secrets(env=None):
    """Загружает секреты в зависимости от окружения"""
    env = env or os.getenv("TEST_ENV", "local")
    
    secrets = {
        "local": {
            "db": "postgresql://localhost/test",
            "api_key": os.getenv("LOCAL_API_KEY"),
        },
        "ci": {
            "db": os.getenv("CI_DB_URL"),
            "api_key": os.getenv("CI_API_KEY"),
        }
    }
    return secrets.get(env, {})
```

## 8. **Опасные анти-паттерны (НИКОГДА так не делайте)**

```python
# ❌ ПЛОХО - жестко закодированные пароли
USERNAME = "admin"
PASSWORD = "password123"  # Утекло в git

# ❌ ПЛОХО - конфиги в коде
class Config:
    SECRET_KEY = "hardcoded-secret"  # Видно всем

# ❌ ПЛОХО - простые файлы без .gitignore
# test_credentials.json в репозитории
```

## 9. **Полный пример безопасной конфигурации**

```python
# project/
# ├── tests/
# │   ├── conftest.py
# │   └── test_api.py
# ├── .env.example          # Шаблон с dummy значениями
# ├── .env                  # Локальные секреты (.gitignore)
# └── .gitignore            # С .env и ключами

# .env.example
TEST_USERNAME=your_test_username_here
TEST_PASSWORD=your_test_password_here
API_KEY=your_api_key_here
# Скопировать в .env и заполнить реальными значениями

# tests/conftest.py
import pytest
import os
from dotenv import load_dotenv

load_dotenv()

def require_env(var_name):
    value = os.getenv(var_name)
    if not value:
        pytest.skip(f"Требуется переменная окружения: {var_name}")
    return value

@pytest.fixture(scope="session")
def test_credentials():
    return {
        "username": require_env("TEST_USERNAME"),
        "password": require_env("TEST_PASSWORD"),
        "api_key": require_env("API_KEY"),
    }
```

## 10. **CI/CD интеграция**

### GitHub Actions
```yaml
# .github/workflows/test.yml
name: Tests
on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Python
        uses: actions/setup-python@v2
      
      - name: Install dependencies
        run: pip install -r requirements.txt
      
      - name: Run tests
        env:
          TEST_USERNAME: ${{ secrets.TEST_USERNAME }}
          TEST_PASSWORD: ${{ secrets.TEST_PASSWORD }}
          API_KEY: ${{ secrets.API_KEY }}
        run: python -m pytest
```

## Критические правила безопасности:

1. **Никогда не коммитьте секреты в Git** - используйте `.gitignore`
2. **Используйте разные учетные данные** для тестов/продакшена
3. **Регулярно ротируйте пароли** в тестовых средах
4. **Минимальные привилегии** - тестовым аккаунтам только нужные права
5. **Логи без паролей** - маскируйте секретные данные в логах

## Для разных команд:

- **Небольшая команда/проект**: `.env` файлы + переменные окружения
- **Средний проект**: `.env` + CI/CD Secrets + шифрование
- **Корпоративный уровень**: HashiCorp Vault/AWS Secrets Manager

Начните с `.env` файлов - это самый простой и эффективный способ для большинства проектов.
