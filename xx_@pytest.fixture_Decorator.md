 Давайте подробно разберем приведенный код, чтобы понять его назначение и функциональность в контексте использования фреймворка тестирования `pytest`.

### Объяснение кода

```python
@pytest.fixture(
    scope="class",
    params=[*role_list],
)
def cur_role(request):
    """Фикстура"""
    # проверка аргументов командной строки
    cur_role = request.param
    print(f"Текущая роль теста - {cur_role}\n")
    return cur_role
```

#### 1. **Понимание декоратора `@pytest.fixture`**
- Декоратор `@pytest.fixture` используется для определения фикстуры в фреймворке `pytest`. Фикстуры служат для настройки состояния или предоставления некоторой функциональности вашим тестам. Они могут готовить контекст или управлять действиями по настройке и завершению.

#### 2. **Параметры фикстуры**
- Фикстура определяется с конкретными параметрами:
  - `scope="class"`: Это означает, что фикстура будет создана один раз для каждого класса тестов. Все методы тестирования в классе будут использовать один и тот же экземпляр фикстуры.
  - `params=[*role_list]`: Это указывает на то, что фикстура будет выполняться для каждого значения в `role_list`. Знак `*` используется для распаковки элементов `role_list`, так что каждый элемент становится отдельным параметром для фикстуры.

#### 3. **Функция `cur_role`**
- Функция `cur_role` принимает объект `request`, который автоматически предоставляется `pytest`. Этот объект дает доступ к контексту теста и позволяет получать информацию о выполняемом в данный момент тесте.

#### 4. **Установка и возврат текущей роли**
- `cur_role = request.param`: Эта строка извлекает текущий параметр (роль), который обрабатывается в текущем выполнении фикстуры. Поскольку `params` содержит несколько значений, это значение будет меняться для каждого теста, использующего эту фикстуру.
- `print(f"Текущая роль теста - {cur_role}\n")`: Эта строка выводит текущую роль, используемую в тесте, в консоль. Это полезно для отладки и ведения логов.
- `return cur_role`: Наконец, функция возвращает текущую роль, делая ее доступной для тестов, которые используют эту фикстуру.

### Пример использования в тестах
Когда вы используете фикстуру `cur_role` в своем классе тестов, каждый тест автоматически получает другое значение `cur_role`, соответствующее элементам из `role_list`. Например:

```python
import pytest

role_list = ['admin', 'user', 'guest']

class TestRoles:
    @pytest.mark.usefixtures("cur_role")
    def test_role_access(self, cur_role):
        # Здесь можно писать тесты, проверяющие права доступа для cur_role
        assert cur_role in ['admin', 'user', 'guest']
```

### Резюме
Фикстура `cur_role` — это мощный способ параметризировать тесты в `pytest`. Она позволяет запускать один и тот же тестовый код для нескольких ролей (или любых других сущностей), что улучшает переиспользуемость и поддерживаемость вашего тестового кода. Каждый тест получает доступ к определенной роли, которая может использоваться во время его выполнения.

__________________________
______________________________


# Лекция: Декораторы функций в Python

## Введение
Подробно изучим декораторы функций в Python. Этот инструмент позволяет модифицировать поведение функций без изменения их кода, что делает их очень полезными в разработке.

### Цели лекции:
- Понять, что такое декораторы.
- Научиться создавать и использовать декораторы.
- Изучить работу с параметрами через `*args` и `**kwargs`.
- Рассмотреть множество примеров применения декораторов.

## 1. Что такое декораторы?

Декораторы в Python — это функции, которые оборачивают другие функции, добавляя им новое поведение перед или после их выполнения. Декораторы позволяют:

- Добавлять функции логирования.
- Выполнять профилирование (измерение времени выполнения).
- Реализовывать кэширование результатов.
- Проверять доступ, а также реализовывать другие тривиальные и сложные задачи.

## 2. Основной синтаксис декораторов

### Пример простого декоратора

Давайте начнем с простого примера.

```python
def my_decorator(func):
    def wrapper():
        print("Что-то делаю перед вызовом функции")
        func()  # Вызов оригинальной функции
        print("Что-то делаю после вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Привет!")

say_hello()
```

### Объяснение кода:
1. **Декоратор**: Мы создаем функцию `my_decorator`, которая принимает другую функцию `func` в качестве параметра.
2. **Обертка**: Внутри `my_decorator` мы определяем функцию `wrapper`, добавляющую дополнительное поведение (вывод сообщений) перед и после вызова оригинальной функции `func()`.
3. **Использование**: Символ `@` перед `say_hello` эквивалентен записи `say_hello = my_decorator(say_hello)`. Это значит, что при вызове `say_hello()` будет выполнен код внутри `wrapper`.

**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет!
Что-то делаю после вызова функции
```

## 3. Декораторы с аргументами

Теперь рассмотрим, как создавать декораторы, которые могут работать с функциями, принимающими аргументы. Для этого мы используем `*args` и `**kwargs`.

### Пример:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        result = func(*args, **kwargs)  # Передаем аргументы в оригинальную функцию
        print("Что-то делаю после вызова функции")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Привет, {name}!")

greet("Мир")
```

### Объяснение кода:
- **`*args` и `**kwargs`**: Эти конструкции позволяют функции `wrapper` принимать любое количество позиционных (`*args`) и именованных аргументов (`**kwargs`).
- **Вызов оригинальной функции**: При вызове `func(*args, **kwargs)`, мы передаем все полученные аргументы в оригинальную функцию `greet`.
  
**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет, Мир!
Что-то делаю после вызова функции
```

## 4. Отображение имен функций

Когда мы начинаем использовать декораторы, оригинальные имена функций могут быть потеряны. Чтобы сохранить метаданные, такие как имя и документацию, используйте `functools.wraps`.

### Пример:

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # Сохраняем метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция приветствует пользователя."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)   # Вывод: Эта функция приветствует пользователя.
```

### Объяснение кода:
- **`@functools.wraps(func)`**: Декоратор `wraps` обновляет функцию `wrapper`, чтобы она сохраняла имя и документацию оригинальной функции, что делает её более «прозрачной».

## 5. Примеры применения декораторов

### 5.1 Декоратор для логирования

Давайте рассмотрим декоратор для логирования вызовов функций:

```python
def logger(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__} с аргументами {args} и {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(3, 5)
print(f"Результат: {result}")
```

### Объяснение кода:
- Этот декоратор выводит имя вызываемой функции и её аргументы. При вызове `add(3, 5)`, он выведет, что функция была вызвана с указанными аргументами.

**Вывод при запуске:**
```
Вызов функции: add с аргументами (3, 5) и {}
Результат: 8
```

### 5.2 Декоратор для измерения времени выполнения

Теперь рассмотрим декоратор, который замеряет время выполнения функции.

```python
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Замеряем время начала
        result = func(*args, **kwargs)
        end_time = time.time()  # Замеряем время конца
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time:.4f} секунд")
        return result
    return wrapper

@timer
def compute_square(n):
    time.sleep(1)  # Имитация длительной операции
    return n ** 2

result = compute_square(10)
```

### Объяснение кода:
- В этом примере декоратор `timer` замеряет время на выполнение функции `compute_square`. Мы используем `time.sleep(1)` для имитации долгой операции, чтобы было видно время выполнения.

**Вывод при запуске:**
```
Время выполнения функции compute_square: 1.0010 секунд
```

## Заключение

Сегодня мы изучили, что такое декораторы в Python, как их создавать, использовать параметры `*args` и `**kwargs`, а также рассмотрели несколько практических примеров. 

Декораторы позволяют легко добавлять общее поведение ко многим функциям без дублирования кода, что делает ваш код более чистым и управляемым.

### Вопросы и ответы

Теперь я готов ответить на ваши вопросы. Спасибо за внимание!

---

Итак мы осветили подробно концепцию декораторов, их создание и использование, включая работу с аргументами.
