 Давайте подробно разберем приведенный код, чтобы понять его назначение и функциональность в контексте использования фреймворка тестирования `pytest`.

### Объяснение кода

```python
@pytest.fixture(
    scope="class",
    params=[*role_list],
)
def cur_role(request):
    """Фикстура"""
    # проверка аргументов командной строки
    cur_role = request.param
    print(f"Текущая роль теста - {cur_role}\n")
    return cur_role
```

#### 1. **Понимание декоратора `@pytest.fixture`**
- Декоратор `@pytest.fixture` используется для определения фикстуры в фреймворке `pytest`. Фикстуры служат для настройки состояния или предоставления некоторой функциональности вашим тестам. Они могут готовить контекст или управлять действиями по настройке и завершению.

#### 2. **Параметры фикстуры**
- Фикстура определяется с конкретными параметрами:
  - `scope="class"`: Это означает, что фикстура будет создана один раз для каждого класса тестов. Все методы тестирования в классе будут использовать один и тот же экземпляр фикстуры.
  - `params=[*role_list]`: Это указывает на то, что фикстура будет выполняться для каждого значения в `role_list`. Знак `*` используется для распаковки элементов `role_list`, так что каждый элемент становится отдельным параметром для фикстуры.

#### 3. **Функция `cur_role`**
- Функция `cur_role` принимает объект `request`, который автоматически предоставляется `pytest`. Этот объект дает доступ к контексту теста и позволяет получать информацию о выполняемом в данный момент тесте.

#### 4. **Установка и возврат текущей роли**
- `cur_role = request.param`: Эта строка извлекает текущий параметр (роль), который обрабатывается в текущем выполнении фикстуры. Поскольку `params` содержит несколько значений, это значение будет меняться для каждого теста, использующего эту фикстуру.
- `print(f"Текущая роль теста - {cur_role}\n")`: Эта строка выводит текущую роль, используемую в тесте, в консоль. Это полезно для отладки и ведения логов.
- `return cur_role`: Наконец, функция возвращает текущую роль, делая ее доступной для тестов, которые используют эту фикстуру.

### Пример использования в тестах
Когда вы используете фикстуру `cur_role` в своем классе тестов, каждый тест автоматически получает другое значение `cur_role`, соответствующее элементам из `role_list`. Например:

```python
import pytest

role_list = ['admin', 'user', 'guest']

class TestRoles:
    @pytest.mark.usefixtures("cur_role")
    def test_role_access(self, cur_role):
        # Здесь можно писать тесты, проверяющие права доступа для cur_role
        assert cur_role in ['admin', 'user', 'guest']
```

### Резюме
Фикстура `cur_role` — это мощный способ параметризировать тесты в `pytest`. Она позволяет запускать один и тот же тестовый код для нескольких ролей (или любых других сущностей), что улучшает переиспользуемость и поддерживаемость вашего тестового кода. Каждый тест получает доступ к определенной роли, которая может использоваться во время его выполнения.

__________________________
______________________________
Полезные ссылки:
- https://rutube.ru/video/dc14a896bc2d4cfc072183931856e20a/?r=wd
- https://rutube.ru/video/d1a60ed2510baf1f11fd05898468d588/?r=wd
- https://rutube.ru/video/c18f95a47ee9be71a050642aded2c2c8/?r=wd
- https://rutube.ru/video/22abf27db311c7332af76efc13327751/?r=wd


# Лекция: Декораторы функций в Python

## Введение
Подробно изучим декораторы функций в Python. Этот инструмент позволяет модифицировать поведение функций без изменения их кода, что делает их очень полезными в разработке.

### Цели лекции:
- Понять, что такое декораторы.
- Научиться создавать и использовать декораторы.
- Изучить работу с параметрами через `*args` и `**kwargs`.
- Рассмотреть множество примеров применения декораторов.

## 1. Что такое декораторы?

Декораторы в Python — это функции, которые оборачивают другие функции, добавляя им новое поведение перед или после их выполнения. Декораторы позволяют:

- Добавлять функции логирования.
- Выполнять измерение времени выполнения.
- Реализовывать кэширование результатов.
- Проверять авторизацию, доступ, а также реализовывать другие задачи.

## 2. Основной синтаксис декораторов

### Пример простого декоратора

Давайте начнем с простого примера.

```python
def my_decorator(func):
    def wrapper():
        print("Что-то делаю перед вызовом функции")
        func()  # Вызов оригинальной функции
        print("Что-то делаю после вызова функции")
    return wrapper # Круглые скобки не добавляем, тк нам не нужно чтоб эта ф-ция здесь выполнилась, нужно только ее передать как объект, а не её результат. Это позволяет другим частям кода вызвать wrapper позже, когда это будет необходимо.

@my_decorator
def say_hello():
    print("Привет!")

say_hello()
```

### Объяснение кода:
1. **Декоратор**: Мы создаем функцию `my_decorator`, которая принимает другую функцию `func` в качестве параметра.
2. **Обертка**: Внутри `my_decorator` мы определяем функцию `wrapper`, добавляющую дополнительное поведение (вывод сообщений) перед и после вызова оригинальной функции `func()`.
3. **Использование**: Символ `@` перед `say_hello` эквивалентен записи `say_hello = my_decorator(say_hello)`. Это значит, что при вызове `say_hello()` будет выполнен код внутри `wrapper`.

**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет!
Что-то делаю после вызова функции
```

## 3. Декораторы с аргументами

Теперь рассмотрим, как создавать декораторы, которые могут работать с функциями, принимающими аргументы. Для этого мы используем `*args` и `**kwargs`.

### Пример:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        result = func(*args, **kwargs)  # Передаем аргументы в оригинальную функцию
        print("Что-то делаю после вызова функции")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Привет, {name}!")

greet("Мир")
```

### Объяснение кода:
- **`*args` и `**kwargs`**: Эти конструкции позволяют функции `wrapper` принимать любое количество позиционных аргументов  (`*args`) и именованных аргументов (`**kwargs`).
- **Вызов оригинальной функции**: При вызове `func(*args, **kwargs)`, мы передаем все полученные аргументы в оригинальную функцию `greet`.
  
**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет, Мир!
Что-то делаю после вызова функции
```

## 4. Отображение имен функций

Когда мы начинаем использовать декораторы, оригинальные имена функций могут быть потеряны. Чтобы сохранить метаданные, такие как имя и документацию, используйте `functools.wraps`.

### Пример:

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # Сохраняем метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция приветствует пользователя."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)   # Вывод: Эта функция приветствует пользователя.
```

### Объяснение кода:
- **`@functools.wraps(func)`**: Декоратор `wraps` обновляет функцию `wrapper`, чтобы она сохраняла имя и документацию оригинальной функции, что делает её более «прозрачной».

## 5. Примеры применения декораторов

### 5.1 Декоратор для логирования

Давайте рассмотрим декоратор для логирования вызовов функций:

```python
def logger(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__} с аргументами {args} и {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(3, 5)
print(f"Результат: {result}")
```

### Объяснение кода:
- Этот декоратор выводит имя вызываемой функции и её аргументы. При вызове `add(3, 5)`, он выведет, что функция была вызвана с указанными аргументами.

**Вывод при запуске:**
```
Вызов функции: add с аргументами (3, 5) и {}
Результат: 8
```

### 5.2 Декоратор для измерения времени выполнения

Теперь рассмотрим декоратор, который замеряет время выполнения функции.

```python
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Замеряем время начала
        result = func(*args, **kwargs)
        end_time = time.time()  # Замеряем время конца
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time:.4f} секунд")
        return result
    return wrapper

@timer
def compute_square(n):
    time.sleep(1)  # Имитация длительной операции
    return n ** 2

result = compute_square(10)
```

### Объяснение кода:
- В этом примере декоратор `timer` замеряет время на выполнение функции `compute_square`. Мы используем `time.sleep(1)` для имитации долгой операции, чтобы было видно время выполнения.

**Вывод при запуске:**
```
Время выполнения функции compute_square: 1.0010 секунд
```

## Заключение

Сегодня мы изучили, что такое декораторы в Python, как их создавать, использовать параметры `*args` и `**kwargs`, а также рассмотрели несколько практических примеров. 

Декораторы позволяют легко добавлять общее поведение ко многим функциям без дублирования кода, что делает ваш код более чистым и управляемым.


Итак мы осветили подробно концепцию декораторов, их создание и использование, включая работу с аргументами.
___






### Декораторы в PyTest
— это мощный инструмент для упрощения и улучшения процесса тестирования в Python. Они позволяют структурировать тесты, добавлять поведение и переопределять параметры, без необходимости создания новых функций или классов. В этой лекции мы рассмотрим основные декораторы, предоставляемые PyTest, и покажем примеры их использования.

---

# Лекция: Декораторы в PyTest

## Введение

Сегодня мы обсудим использование декораторов в библиотеке PyTest для тестирования ваших приложений на Python. Декораторы в PyTest позволяют управлять поведением тестов, например, для повторного запуска, настройки среды выполнения, управления зависимостями и т.д.

### Цели лекции:
- Понять, что такое декораторы в PyTest.
- Изучить основные декораторы и их применение.
- Рассмотреть примеры использования декораторов для улучшения тестирования.

## 1. Основы PyTest

Перед тем как углубляться в декораторы, давайте коротко вспомним, что такое PyTest. PyTest — это популярная библиотека для написания тестов в Python, которая поддерживает простые тесты, сложные функциональные тесты и интеграционные тесты.

### Установка PyTest

Если у вас еще не установлен PyTest, его можно установить через pip:

```bash
pip install pytest
```

## 2. Основные декораторы PyTest

### 2.1 `@pytest.mark.parametrize`

Этот декоратор используется для параметризации тестов, позволяя вам запускать один и тот же тест с различными наборами входных данных.

#### Пример:

```python
import pytest

@pytest.mark.parametrize("input, expected", [
    (1, 2),
    (2, 3),
    (3, 4)
])
def test_add_one(input, expected):
    assert input + 1 == expected
```

### Объяснение:
- **`@pytest.mark.parametrize`**: Декоратор принимает два параметра: имя аргументов и список значений. В данном случае `input` и `expected` будут переданы в тест `test_add_one` как параметры.
- **Запуск теста**: PyTest запустит `test_add_one` трижды: с (1, 2), (2, 3) и (3, 4).

### 2.2 `@pytest.mark.skip` и `@pytest.mark.skipif`

Эти декораторы позволяют пропускать тесты. `@pytest.mark.skip` всегда пропускает тест, тогда как `@pytest.mark.skipif` пропускает его при выполнении определенного условия.

#### Пример:

```python
import pytest

@pytest.mark.skip(reason="Тест временно отключен")
def test_func_1():
    assert True

@pytest.mark.skipif(1 + 1 == 2, reason="Пропускаем, когда 1 + 1 равно 2")
def test_func_2():
    assert False  # Этот тест не будет выполнен
```

### Объяснение:
- **`@pytest.mark.skip`**: Тест `test_func_1` полностью пропускается, и PyTest выведет сообщение о причине.
- **`@pytest.mark.skipif`**: Тест `test_func_2` будет пропущен, поскольку условие `1 + 1 == 2` истинно.

### 2.3 `@pytest.mark.xfail`

Этот декоратор позволяет пометить тест, который ожидается как неуспешный. Если тест не проходит, это не считается ошибкой.

#### Пример:

```python
import pytest

@pytest.mark.xfail
def test_func_xfail():
    assert False  # Ожидается, что этот тест завершится с ошибкой
```

### Объяснение:
- **`@pytest.mark.xfail`**: Если тест `test_func_xfail` завершится с ошибкой, PyTest отобразит это, но не пометит тест как провалившийся.

### 2.4 `@pytest.fixture`

Этот декоратор используется для создания "фабрик" для тестов, позволяя выполнять общие настройки, которые могут использоваться в нескольких тестах.

#### Пример:

```python
import pytest

@pytest.fixture
def sample_data():
    return {"key": "value"}

def test_data(sample_data):
    assert sample_data["key"] == "value"
```

### Объяснение:
- **`@pytest.fixture`**: Функция `sample_data` создаёт данные, которые могут быть использованы в тестах. PyTest автоматически находит любые функции, помеченные этим декоратором, и передает их в тесты, в которых они фигурируют в качестве аргументов.
  
Когда вы вызываете тест, который нуждается в `sample_data`, PyTest сначала выполнит функцию `sample_data`, а затем передаст результат в тест:

```python
def test_data(sample_data):
    assert sample_data["key"] == "value"  # Проверка, что данные возвращаются корректно
```

Такой подход позволяет удобно использовать общие ресурсы и настраивать их один раз в месте, а не дублировать код в каждом тесте.

### 2.5 `@pytest.mark.usefixtures`

Этот декоратор позволяет вам использовать фикстуры, даже если вы не собираетесь напрямую передавать их в тестовую функцию.

#### Пример:

```python
import pytest

@pytest.fixture
def prepare_data():
    return {"key": "value"}

@pytest.mark.usefixtures("prepare_data")
def test_data(prepare_data):
    assert prepare_data["key"] == "value"
```

### Объяснение:
- **`@pytest.mark.usefixtures`**: В этом примере фикстура `prepare_data` используется в тесте `test_data`, даже если сама фикстура не передаётся как аргумент в функцию теста. Это полезно, когда вы хотите применять фикстуру к нескольким тестам сразу.

### 2.6 Декораторы для долговременных тестов

Вы также можете создавать ваши собственные декораторы, используя функциональность PyTest. Например, вы можете создать декоратор для управления состоянием теста или для повторного запуска при сбоях.

#### Пример:

```python
import pytest

def retry(test):
    """Декоратор для повторного выполнения теста при сбое."""
    def wrapped(*args, **kwargs):
        for _ in range(3):  # Повторяем тест трижды
            try:
                return test(*args, **kwargs)
            except Exception as e:
                print(f"Тест не прошел: {str(e)}. Повторяем...")
        pytest.fail("Тест провалился после трех попыток.")
    return wrapped

@retry
def test_something():
    assert False  # Этот тест намеренно неуспешен
```

### Объяснение:
- В этом примере мы создали собственный декоратор `retry`, который позволяет повторно запускать тест до трех раз, если он завершается ошибкой. Если все три попытки завершаются неудачно, тест считается провалившимся.

## Заключение

В ходе лекции мы рассмотрели основные декораторы в PyTest и их назначение. 

### Основные моменты:

- **`@pytest.mark.parametrize`**: Позволяет запускать один тест с разными параметрами.
- **`@pytest.mark.skip`** и **`@pytest.mark.skipif`**: Используются для пропуска тестов.
- **`@pytest.mark.xfail`**: Позволяет пометить ожидаемо неуспешные тесты.
- **`@pytest.fixture`**: Создает общие ресурсы, которые могут использоваться в нескольких тестах.
- **`@pytest.mark.usefixtures`**: Позволяет явно использовать фикстуры в тестах без передачи их как аргументов.

Вы также узнали, как создавать собственные декораторы для повторного выполнения тестов или любой другой функциональности в вашей программной среде.
_________________________________
https://rutube.ru/video/dc14a896bc2d4cfc072183931856e20a/?r=wd
```
# Декораторы функций
def func_decorator(func):
    def wrapper():
        print("------ что-то делаем перед вызовом функции ------")
        func()
        print("------ что-то делаем после вызова функции ------")
    return wrapper()
#
#
# def some_func():
#     print("Вызов функции some_func")
#
#
#
# some_func()

# f = func_decorator(some_func)
# f

#
# some_func = func_decorator(some_func)
# some_func

##########################
# def func_decorator(func):
#     def wrapper(title):
#         print("------ что-то делаем перед вызовом функции ------")
#         func(title)
#         print("------ что-то делаем после вызова функции ------")
#     return wrapper
# def some_func(title):
#     print(f"title = {title}")
#
# some_func = func_decorator(some_func)
# some_func("Python навсегда!")


################################
def func_decorator(func):
    def wrapper(*args, **kwargs):
        print("------ что-то делаем перед вызовом функции ------")
        func(*args, **kwargs)
        print("------ что-то делаем после вызова функции ------")
    return wrapper


def some_func(title, tag):
    print(f"title = {title}, tag = {tag}")
    return f"<{tag}>{title}</{tag}>"

some_func = func_decorator(some_func)
some_func("Python навсегда!", "h1")

################################

# def func_decorator(func):
#     def wrapper(*args, **kwargs):
#         print("------ что-то делаем перед вызовом функции ------")
#         func(*args, **kwargs)
#         print("------ что-то делаем после вызова функции ------")
#         # return res
#
#     return wrapper
#
#
# def some_func(title, tag):
#     print(f"title = {title}, tag = {tag}")
#     return f"<{tag}>{title}</{tag}>"
#
#
# some_func = func_decorator(some_func)
# res = some_func("Python навсегда!", "h1")
# print(res)

################################

# def func_decorator(func):
#     def wrapper(*args, **kwargs):
#         print("------ что-то делаем перед вызовом функции ------")
#         res = func(*args, **kwargs)
#         print("------ что-то делаем после вызова функции ------")
#         return res
#
#     return wrapper
#
#
# def some_func(title, tag):
#     print(f"title = {title}, tag = {tag}")
#     return f"<{tag}>{title}</{tag}>"
#
#
# some_func = func_decorator(some_func)
# res = some_func("Python навсегда!", "h1")
# print(res)
# #################################
# import time
#
# def test_time(func):
#     def wrapper(*args, **kwargs):
#         st = time.time()
#         res = func(*args, **kwargs)
#         et = time.time()
#         dt = et - st
#         print(f"Время работы: {dt} сек")
#         return res
#
#     return wrapper
#
#
# def get_nod(a, b):
#     while a != b:
#         if a > b:
#             a -= b
#         else:
#             b -= a
#     return a
#
#
# def get_fast_nod(a, b):
#     if a < b:
#         a, b = b, a
#     while b:
#         a, b = b, a % b
#
#     return a
#
#
# get_nod = test_time(get_nod)
# get_fast_nod = test_time(get_fast_nod)
#
# res = get_nod(2, 1000000)
# res2 = get_fast_nod(2, 1000000)
# print(res, res2)

```
Предположим, у нас есть функция, которая называется func_decorator, и она будет принимать один параметр с именем func. Этот параметр будет ссылкой на некую функцию.
def func_decorator(func):
А внутри вот этой функции func_decorator будет ещё одна функция с именем wrapper. Это внутренняя функция может выполнить некиe команды до вызова вот этой вот функции func и некиe команды после вызова этой функции func.
Собственно ради этого мы её и описали. То есть функция wrapper, она не просто вызывает вот эту вот функцию func, ссылку на которую мы передаём, но и ещё дополнительно делает некие операции до её вызова и после её вызова.
Ну, соответственно, вот эта вот внешняя функция, func_decorator, должна вернуть ссылку на внутреннюю функцию. И наш декоратор в самом простом варианте, в общем-то, готов. 
```
def func_decorator(func):
    def wrapper():
        print("------ что-то делаем перед вызовом функции ------")
        func()
        print("------ что-то делаем после вызова функции ------")
    return wrapper()
```
Теперь мы можем с вами объявить некоторую стороннюю функцию, пусть она называется так вот:  
```
some_func()
def some_func():
    print("Вызов функции some_func")
```
и просто выводит в консоль некоторое сообщение ("Вызов функции some_func"). Если мы вызовем эту функцию Самфанк вот просто вот так вот через её имя, 
some_func()
то мы соответственно в консоли увидим вот эту вот строчку ("Вызов функции some_func"). То есть в принципе тут ничего особенного и нету.
Но мы можем вызвать эту же самую функцию и по-другому, используя вот эту функцию, func_decorator. Давайте это сделаем. Значит, вот здесь вот я сделаю следующим образом: определю некую переменную F, которая будет ссылаться на вот эту вот внутреннюю функцию ропер. А в качестве аргумента вот этого func_decorator мы, соответственно, передадим ссылку на вот эту вот нашу функцию some_func()
```
f = func_decorator(some_func())
f()
```
Ну а дальше вместо вот этого вот имени сам функ мы напишем F просто. Запустим нашу программу и смотрите, что у нас получилось. Мы не просто вызвали вот эту функцию сам функ, но что-то ещё сделали до её вызова и после её вызова. То есть вот эти вот строчки, вот всё, что мы здесь вот с вами написали, по сути работает следующим образом.

![image](https://github.com/user-attachments/assets/e7cfca8b-5697-4f9c-8ca2-4e3a121b2f5c)

У нас есть некая перемнная F в глобальной области видимости, которая ссылается на вот эту вот внутреннюю функцию wrapper, определённая во внешней функции func декоратор. А вот этот параметр func, он как раз ссылается на вот эту вот функцию some_func, которую мы с вами определили ниже. То есть когда мы вызываем вот эту вот функцию F, то на самом деле мы вызываем вот эту вот внутреннюю функцию wrapper, она в свою очередь вызывает вот эту вот функцию func, то есть вот эту вот функцию some_func и дополнительно что-то делает перед её вызовом и после её вызова.
Вот в этом и есть смысл декоратора. Благодаря вот этой вот внутренней функции, он расширяет функционал некой другой сторонней функции. Но чтоб нам в программе не создавать новые переменные вот здесь вот, обычно при декорировании тех или иных функций создают ссылку на то же самое имя, то есть делают вот так вот:
```
some_func = func_decorator(some_func)
some_func
```
 some_func равняется, здесь func_decorator в нашем случае, и та же самая ссылка на вот эту вот функцию some_func. В итоге функция some_func, она как бы меняет свою работу. Она теперь не просто будет выводить что-то в консоль, но дополнительно будет выполняться операции до её вызова и после её вызова. То есть благодаря вот этому замыканию, мы декорировали функцию и расширили её функционал.
Однако, если сейчас вот мы в эту функцию some func добавим какой-либо параметр, ну, например, вот так вот, title, и в функции print выведем этот параметр, соответственно, в консоль, ну, например, вот таким вот образом, то, соответственно, при вызове вот этой функции some func, по идее мы, конечно же, вот этот вот аргумент здесь должны прописать, ну, например, вот так вот. 
```def some_func(title):
    print(f"title = {title}")

some_func = func_decorator(some_func)
some_func("Python навсегда!")
```
Но если мы сейчас запустим нашу программу, то будет ошибка, потому что вот эта вот внутренняя функция wrapper, она не имеет никаких аргументов здесь. Тогда как у нас вот у этой функции some func сейчас присутствует вот один параметр.
То есть, чтобы в нашей программе не было ошибок, в самом простом случае, мы, конечно же, вот здесь вот можем просто вот так вот прописать один параметр вот у этой внутренней функции. Ну и, соответственно, вызвать вот эту вот внутреннюю функцию тоже с одним аргументом title. Если запустим программу, то уже ошибок не будет. И мы здесь видим title, «Python навсегда», что-то делаем перед и что-то делаем после.
```
def func_decorator(func):
    def wrapper(title):
        print("------ что-то делаем перед вызовом функции ------")
        func(title)
        print("------ что-то делаем после вызова функции ------")
    return wrapper
```
 Но вот в таком вот виде наш декоратор работает как бы в частном случае. То есть, если вот у этой функции,  появятся какие-то другие параметры или вообще не будет никаких параметров, то вот этот вот декоратор снова перестанет работать. Как бы сделать так, чтобы он был универсальным, то есть
писать его в универсальном виде. 

Конечно, для этого вот здесь вот во внутренней функции нужно указать и принимать произвольное число фактических параметров и формальных параметров. А далее вот здесь вот при вызове этой функции мы их распаковываем и передаём. То есть, если они есть, то, соответственно, будут передаваться, если они будут отсутствовать, то ничего передаваться этой функции не будет. То есть вот таким вот образом мы с вами универсально определили декоратор для произвольных функций. И смотрите, если запустим нашу программу, там никаких ошибок не будет, всё работает. Если добавим ещё один параметр, ну, допустим, с именем тег и здесь его тоже выведем, соответственно, здесь вот ниже, при вызове вот этой вот декорируемой функции, мы также должны указать второй аргумент, ну, допустим, h1. И, если мы запустим программу, то она у нас работает и при этом декоратор вот этот вот мы никак не меняли.

То есть он у нас теперь стал универсальным. Мы можем вызывать функции с произвольным числом аргументов. И остался здесь последний штрих. Смотрите, если вот эта вот наша функция самфанк будет что-то возвращать, ну, например, вот такую вот строку, то, конечно же, вот здесь вот мы её не получим. Если вот здесь вот взять вот какой-нибудь результат res и вывести его в консоль, запустить программу, то увидим значение NaN. Почему так произошло? Потому что вот эта вот внутренняя функция в нашем декораторе ничего не возвращает. То есть она выполняет вот эту вот функцию, но результат её работы нигде не возвращается. Давайте это поправим. Значит, вот здесь вот я тоже напишу res равняется. Ну и то, что вот она выполнит, то, что она вернёт, нужно вернуть и вот этой вот внутренней функции wrapper. То есть написать ещё вот здесь вот return res. Всё. Если мы теперь запустим нашу программу, то вместо NaN увидим ту строчку, которая возвратила вот эта вот функция самфанк.
То есть вот так вот мы с вами определили универсальный декоратор для любых функций. То есть мы можем передавать вот здесь вот при создании декоратора любые функции, прописывать вот здесь вот абсолютно любые функции с произвольным числом параметров, возвращающие любые значения и, соответственно, декорировать их. Но правда при декорировании мы просто будем вот здесь вот видеть дополнительное сообщение, что это делаем перед вызовом функции и что это делаем после вызова функции. Конечно, это вот лишь пример того, как можно создавать декораторы.
Но всё же, зачем он нужен? Давайте я приведу такой пример. Предположим, мы хотим протестировать различные функции на скорость их работы. Для этого возьмём функцию, которая реализует медленный алгоритм Евклида для двух натуральных чисел. Мы уже делали этот алгоритм Евклида, поэтому я просто вот пропишу функцию, которая реализует этот медленный алгоритм Евклида. И она выглядит следующим образом. Значит, назову её просто get nod. Здесь два параметра А и B, то есть два натуральных числа. И вот медленный алгоритм Евклида. Если вам непонятно, как работает эта функция, то смотрите это занятие. Здесь я не буду на это отвлекаться. Главное, что у нас есть функция, она как-то работает и выдаёт некий результат. А далее мы пропишем тестировщик. Пусть он называется у нас вот так вот. Вместо func decorator я напишу другое имя - test time. То есть наш декоратор будет называться test time и как раз замерит скорость работы функции.
Здесь параметр будет функ, пусть останется таким же. И внутри, вместо вот этого принта, мы будем замерять скорость работы этой самой функции. Для этого я воспользуюсь модулем Time и вызову функцию Time для того, чтобы замерить текущее время. Здесь будет, значит, начальное время, ну а ниже мы, соответственно, замерим конечное время работы. Вычислим разность между конечным временем и начальным и выведем полученную информацию в консоль, то есть время работы функции столько-то секунд. Всё, наш декоратор, который измеряет скорость работы той или иной функции, готов. Причём он универсальный, мы можем измерять скорость работы произвольных функций. Далее выше вот здесь вот нам нужно импортировать, соответственно, вот этот вот модуль Time, ну и декорировать вот эту вот функцию get note. Я сделаю это следующим образом. Вместо сам функции здесь будет get note. Далее у нас здесь тест Time.
