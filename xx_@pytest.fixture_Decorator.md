 Давайте подробно разберем приведенный код, чтобы понять его назначение и функциональность в контексте использования фреймворка тестирования `pytest`.

### Объяснение кода

```python
@pytest.fixture(
    scope="class",
    params=[*role_list],
)
def cur_role(request):
    """Фикстура"""
    # проверка аргументов командной строки
    cur_role = request.param
    print(f"Текущая роль теста - {cur_role}\n")
    return cur_role
```

#### 1. **Понимание декоратора `@pytest.fixture`**
- Декоратор `@pytest.fixture` используется для определения фикстуры в фреймворке `pytest`. Фикстуры служат для настройки состояния или предоставления некоторой функциональности вашим тестам. Они могут готовить контекст или управлять действиями по настройке и завершению.

#### 2. **Параметры фикстуры**
- Фикстура определяется с конкретными параметрами:
  - `scope="class"`: Это означает, что фикстура будет создана один раз для каждого класса тестов. Все методы тестирования в классе будут использовать один и тот же экземпляр фикстуры.
  - `params=[*role_list]`: Это указывает на то, что фикстура будет выполняться для каждого значения в `role_list`. Знак `*` используется для распаковки элементов `role_list`, так что каждый элемент становится отдельным параметром для фикстуры.

#### 3. **Функция `cur_role`**
- Функция `cur_role` принимает объект `request`, который автоматически предоставляется `pytest`. Этот объект дает доступ к контексту теста и позволяет получать информацию о выполняемом в данный момент тесте.

#### 4. **Установка и возврат текущей роли**
- `cur_role = request.param`: Эта строка извлекает текущий параметр (роль), который обрабатывается в текущем выполнении фикстуры. Поскольку `params` содержит несколько значений, это значение будет меняться для каждого теста, использующего эту фикстуру.
- `print(f"Текущая роль теста - {cur_role}\n")`: Эта строка выводит текущую роль, используемую в тесте, в консоль. Это полезно для отладки и ведения логов.
- `return cur_role`: Наконец, функция возвращает текущую роль, делая ее доступной для тестов, которые используют эту фикстуру.

### Пример использования в тестах
Когда вы используете фикстуру `cur_role` в своем классе тестов, каждый тест автоматически получает другое значение `cur_role`, соответствующее элементам из `role_list`. Например:

```python
import pytest

role_list = ['admin', 'user', 'guest']

class TestRoles:
    @pytest.mark.usefixtures("cur_role")
    def test_role_access(self, cur_role):
        # Здесь можно писать тесты, проверяющие права доступа для cur_role
        assert cur_role in ['admin', 'user', 'guest']
```

### Резюме
Фикстура `cur_role` — это мощный способ параметризировать тесты в `pytest`. Она позволяет запускать один и тот же тестовый код для нескольких ролей (или любых других сущностей), что улучшает переиспользуемость и поддерживаемость вашего тестового кода. Каждый тест получает доступ к определенной роли, которая может использоваться во время его выполнения.

__________________________
______________________________
Полезные ссылки:
https://rutube.ru/video/dc14a896bc2d4cfc072183931856e20a/?r=wd

# Лекция: Декораторы функций в Python

## Введение
Подробно изучим декораторы функций в Python. Этот инструмент позволяет модифицировать поведение функций без изменения их кода, что делает их очень полезными в разработке.

### Цели лекции:
- Понять, что такое декораторы.
- Научиться создавать и использовать декораторы.
- Изучить работу с параметрами через `*args` и `**kwargs`.
- Рассмотреть множество примеров применения декораторов.

## 1. Что такое декораторы?

Декораторы в Python — это функции, которые оборачивают другие функции, добавляя им новое поведение перед или после их выполнения. Декораторы позволяют:

- Добавлять функции логирования.
- Выполнять измерение времени выполнения.
- Реализовывать кэширование результатов.
- Проверять авторизацию, доступ, а также реализовывать другие задачи.

## 2. Основной синтаксис декораторов

### Пример простого декоратора

Давайте начнем с простого примера.

```python
def my_decorator(func):
    def wrapper():
        print("Что-то делаю перед вызовом функции")
        func()  # Вызов оригинальной функции
        print("Что-то делаю после вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Привет!")

say_hello()
```

### Объяснение кода:
1. **Декоратор**: Мы создаем функцию `my_decorator`, которая принимает другую функцию `func` в качестве параметра.
2. **Обертка**: Внутри `my_decorator` мы определяем функцию `wrapper`, добавляющую дополнительное поведение (вывод сообщений) перед и после вызова оригинальной функции `func()`.
3. **Использование**: Символ `@` перед `say_hello` эквивалентен записи `say_hello = my_decorator(say_hello)`. Это значит, что при вызове `say_hello()` будет выполнен код внутри `wrapper`.

**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет!
Что-то делаю после вызова функции
```

## 3. Декораторы с аргументами

Теперь рассмотрим, как создавать декораторы, которые могут работать с функциями, принимающими аргументы. Для этого мы используем `*args` и `**kwargs`.

### Пример:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        result = func(*args, **kwargs)  # Передаем аргументы в оригинальную функцию
        print("Что-то делаю после вызова функции")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Привет, {name}!")

greet("Мир")
```

### Объяснение кода:
- **`*args` и `**kwargs`**: Эти конструкции позволяют функции `wrapper` принимать любое количество позиционных аргументов  (`*args`) и именованных аргументов (`**kwargs`).
- **Вызов оригинальной функции**: При вызове `func(*args, **kwargs)`, мы передаем все полученные аргументы в оригинальную функцию `greet`.
  
**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет, Мир!
Что-то делаю после вызова функции
```

## 4. Отображение имен функций

Когда мы начинаем использовать декораторы, оригинальные имена функций могут быть потеряны. Чтобы сохранить метаданные, такие как имя и документацию, используйте `functools.wraps`.

### Пример:

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # Сохраняем метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция приветствует пользователя."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)   # Вывод: Эта функция приветствует пользователя.
```

### Объяснение кода:
- **`@functools.wraps(func)`**: Декоратор `wraps` обновляет функцию `wrapper`, чтобы она сохраняла имя и документацию оригинальной функции, что делает её более «прозрачной».

## 5. Примеры применения декораторов

### 5.1 Декоратор для логирования

Давайте рассмотрим декоратор для логирования вызовов функций:

```python
def logger(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__} с аргументами {args} и {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(3, 5)
print(f"Результат: {result}")
```

### Объяснение кода:
- Этот декоратор выводит имя вызываемой функции и её аргументы. При вызове `add(3, 5)`, он выведет, что функция была вызвана с указанными аргументами.

**Вывод при запуске:**
```
Вызов функции: add с аргументами (3, 5) и {}
Результат: 8
```

### 5.2 Декоратор для измерения времени выполнения

Теперь рассмотрим декоратор, который замеряет время выполнения функции.

```python
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Замеряем время начала
        result = func(*args, **kwargs)
        end_time = time.time()  # Замеряем время конца
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time:.4f} секунд")
        return result
    return wrapper

@timer
def compute_square(n):
    time.sleep(1)  # Имитация длительной операции
    return n ** 2

result = compute_square(10)
```

### Объяснение кода:
- В этом примере декоратор `timer` замеряет время на выполнение функции `compute_square`. Мы используем `time.sleep(1)` для имитации долгой операции, чтобы было видно время выполнения.

**Вывод при запуске:**
```
Время выполнения функции compute_square: 1.0010 секунд
```

## Заключение

Сегодня мы изучили, что такое декораторы в Python, как их создавать, использовать параметры `*args` и `**kwargs`, а также рассмотрели несколько практических примеров. 

Декораторы позволяют легко добавлять общее поведение ко многим функциям без дублирования кода, что делает ваш код более чистым и управляемым.


Итак мы осветили подробно концепцию декораторов, их создание и использование, включая работу с аргументами.
___






### Декораторы в PyTest
— это мощный инструмент для упрощения и улучшения процесса тестирования в Python. Они позволяют структурировать тесты, добавлять поведение и переопределять параметры, без необходимости создания новых функций или классов. В этой лекции мы рассмотрим основные декораторы, предоставляемые PyTest, и покажем примеры их использования.

---

# Лекция: Декораторы в PyTest

## Введение

Сегодня мы обсудим использование декораторов в библиотеке PyTest для тестирования ваших приложений на Python. Декораторы в PyTest позволяют управлять поведением тестов, например, для повторного запуска, настройки среды выполнения, управления зависимостями и т.д.

### Цели лекции:
- Понять, что такое декораторы в PyTest.
- Изучить основные декораторы и их применение.
- Рассмотреть примеры использования декораторов для улучшения тестирования.

## 1. Основы PyTest

Перед тем как углубляться в декораторы, давайте коротко вспомним, что такое PyTest. PyTest — это популярная библиотека для написания тестов в Python, которая поддерживает простые тесты, сложные функциональные тесты и интеграционные тесты.

### Установка PyTest

Если у вас еще не установлен PyTest, его можно установить через pip:

```bash
pip install pytest
```

## 2. Основные декораторы PyTest

### 2.1 `@pytest.mark.parametrize`

Этот декоратор используется для параметризации тестов, позволяя вам запускать один и тот же тест с различными наборами входных данных.

#### Пример:

```python
import pytest

@pytest.mark.parametrize("input, expected", [
    (1, 2),
    (2, 3),
    (3, 4)
])
def test_add_one(input, expected):
    assert input + 1 == expected
```

### Объяснение:
- **`@pytest.mark.parametrize`**: Декоратор принимает два параметра: имя аргументов и список значений. В данном случае `input` и `expected` будут переданы в тест `test_add_one` как параметры.
- **Запуск теста**: PyTest запустит `test_add_one` трижды: с (1, 2), (2, 3) и (3, 4).

### 2.2 `@pytest.mark.skip` и `@pytest.mark.skipif`

Эти декораторы позволяют пропускать тесты. `@pytest.mark.skip` всегда пропускает тест, тогда как `@pytest.mark.skipif` пропускает его при выполнении определенного условия.

#### Пример:

```python
import pytest

@pytest.mark.skip(reason="Тест временно отключен")
def test_func_1():
    assert True

@pytest.mark.skipif(1 + 1 == 2, reason="Пропускаем, когда 1 + 1 равно 2")
def test_func_2():
    assert False  # Этот тест не будет выполнен
```

### Объяснение:
- **`@pytest.mark.skip`**: Тест `test_func_1` полностью пропускается, и PyTest выведет сообщение о причине.
- **`@pytest.mark.skipif`**: Тест `test_func_2` будет пропущен, поскольку условие `1 + 1 == 2` истинно.

### 2.3 `@pytest.mark.xfail`

Этот декоратор позволяет пометить тест, который ожидается как неуспешный. Если тест не проходит, это не считается ошибкой.

#### Пример:

```python
import pytest

@pytest.mark.xfail
def test_func_xfail():
    assert False  # Ожидается, что этот тест завершится с ошибкой
```

### Объяснение:
- **`@pytest.mark.xfail`**: Если тест `test_func_xfail` завершится с ошибкой, PyTest отобразит это, но не пометит тест как провалившийся.

### 2.4 `@pytest.fixture`

Этот декоратор используется для создания "фабрик" для тестов, позволяя выполнять общие настройки, которые могут использоваться в нескольких тестах.

#### Пример:

```python
import pytest

@pytest.fixture
def sample_data():
    return {"key": "value"}

def test_data(sample_data):
    assert sample_data["key"] == "value"
```

### Объяснение:
- **`@pytest.fixture`**: Функция `sample_data` создаёт данные, которые могут быть использованы в тестах. PyTest автоматически находит любые функции, помеченные этим декоратором, и передает их в тесты, в которых они фигурируют в качестве аргументов.
  
Когда вы вызываете тест, который нуждается в `sample_data`, PyTest сначала выполнит функцию `sample_data`, а затем передаст результат в тест:

```python
def test_data(sample_data):
    assert sample_data["key"] == "value"  # Проверка, что данные возвращаются корректно
```

Такой подход позволяет удобно использовать общие ресурсы и настраивать их один раз в месте, а не дублировать код в каждом тесте.

### 2.5 `@pytest.mark.usefixtures`

Этот декоратор позволяет вам использовать фикстуры, даже если вы не собираетесь напрямую передавать их в тестовую функцию.

#### Пример:

```python
import pytest

@pytest.fixture
def prepare_data():
    return {"key": "value"}

@pytest.mark.usefixtures("prepare_data")
def test_data(prepare_data):
    assert prepare_data["key"] == "value"
```

### Объяснение:
- **`@pytest.mark.usefixtures`**: В этом примере фикстура `prepare_data` используется в тесте `test_data`, даже если сама фикстура не передаётся как аргумент в функцию теста. Это полезно, когда вы хотите применять фикстуру к нескольким тестам сразу.

### 2.6 Декораторы для долговременных тестов

Вы также можете создавать ваши собственные декораторы, используя функциональность PyTest. Например, вы можете создать декоратор для управления состоянием теста или для повторного запуска при сбоях.

#### Пример:

```python
import pytest

def retry(test):
    """Декоратор для повторного выполнения теста при сбое."""
    def wrapped(*args, **kwargs):
        for _ in range(3):  # Повторяем тест трижды
            try:
                return test(*args, **kwargs)
            except Exception as e:
                print(f"Тест не прошел: {str(e)}. Повторяем...")
        pytest.fail("Тест провалился после трех попыток.")
    return wrapped

@retry
def test_something():
    assert False  # Этот тест намеренно неуспешен
```

### Объяснение:
- В этом примере мы создали собственный декоратор `retry`, который позволяет повторно запускать тест до трех раз, если он завершается ошибкой. Если все три попытки завершаются неудачно, тест считается провалившимся.

## Заключение

В ходе лекции мы рассмотрели основные декораторы в PyTest и их назначение. 

### Основные моменты:

- **`@pytest.mark.parametrize`**: Позволяет запускать один тест с разными параметрами.
- **`@pytest.mark.skip`** и **`@pytest.mark.skipif`**: Используются для пропуска тестов.
- **`@pytest.mark.xfail`**: Позволяет пометить ожидаемо неуспешные тесты.
- **`@pytest.fixture`**: Создает общие ресурсы, которые могут использоваться в нескольких тестах.
- **`@pytest.mark.usefixtures`**: Позволяет явно использовать фикстуры в тестах без передачи их как аргументов.

Вы также узнали, как создавать собственные декораторы для повторного выполнения тестов или любой другой функциональности в вашей программной среде.

