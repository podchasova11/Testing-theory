 Давайте подробно разберем приведенный код, чтобы понять его назначение и функциональность в контексте использования фреймворка тестирования `pytest`.

### Объяснение кода

```python
@pytest.fixture(
    scope="class",
    params=[*role_list],
)
def cur_role(request):
    """Фикстура"""
    # проверка аргументов командной строки
    cur_role = request.param
    print(f"Текущая роль теста - {cur_role}\n")
    return cur_role
```

#### 1. **Понимание декоратора `@pytest.fixture`**
- Декоратор `@pytest.fixture` используется для определения фикстуры в фреймворке `pytest`. Фикстуры служат для настройки состояния или предоставления некоторой функциональности вашим тестам. Они могут готовить контекст или управлять действиями по настройке и завершению.

#### 2. **Параметры фикстуры**
- Фикстура определяется с конкретными параметрами:
  - `scope="class"`: Это означает, что фикстура будет создана один раз для каждого класса тестов. Все методы тестирования в классе будут использовать один и тот же экземпляр фикстуры.
  - `params=[*role_list]`: Это указывает на то, что фикстура будет выполняться для каждого значения в `role_list`. Знак `*` используется для распаковки элементов `role_list`, так что каждый элемент становится отдельным параметром для фикстуры.

#### 3. **Функция `cur_role`**
- Функция `cur_role` принимает объект `request`, который автоматически предоставляется `pytest`. Этот объект дает доступ к контексту теста и позволяет получать информацию о выполняемом в данный момент тесте.

#### 4. **Установка и возврат текущей роли**
- `cur_role = request.param`: Эта строка извлекает текущий параметр (роль), который обрабатывается в текущем выполнении фикстуры. Поскольку `params` содержит несколько значений, это значение будет меняться для каждого теста, использующего эту фикстуру.
- `print(f"Текущая роль теста - {cur_role}\n")`: Эта строка выводит текущую роль, используемую в тесте, в консоль. Это полезно для отладки и ведения логов.
- `return cur_role`: Наконец, функция возвращает текущую роль, делая ее доступной для тестов, которые используют эту фикстуру.

### Пример использования в тестах
Когда вы используете фикстуру `cur_role` в своем классе тестов, каждый тест автоматически получает другое значение `cur_role`, соответствующее элементам из `role_list`. Например:

```python
import pytest

role_list = ['admin', 'user', 'guest']

class TestRoles:
    @pytest.mark.usefixtures("cur_role")
    def test_role_access(self, cur_role):
        # Здесь можно писать тесты, проверяющие права доступа для cur_role
        assert cur_role in ['admin', 'user', 'guest']
```

### Резюме
Фикстура `cur_role` — это мощный способ параметризировать тесты в `pytest`. Она позволяет запускать один и тот же тестовый код для нескольких ролей (или любых других сущностей), что улучшает переиспользуемость и поддерживаемость вашего тестового кода. Каждый тест получает доступ к определенной роли, которая может использоваться во время его выполнения.

__________________________
______________________________
Полезные ссылки:
- https://rutube.ru/video/dc14a896bc2d4cfc072183931856e20a/?r=wd
- https://rutube.ru/video/d1a60ed2510baf1f11fd05898468d588/?r=wd
- https://rutube.ru/video/c18f95a47ee9be71a050642aded2c2c8/?r=wd
- https://rutube.ru/video/22abf27db311c7332af76efc13327751/?r=wd


# Лекция: Декораторы функций в Python

## Введение
Подробно изучим декораторы функций в Python. Этот инструмент позволяет модифицировать поведение функций без изменения их кода, что делает их очень полезными в разработке.

### Цели лекции:
- Понять, что такое декораторы.
- Научиться создавать и использовать декораторы.
- Изучить работу с параметрами через `*args` и `**kwargs`.
- Рассмотреть множество примеров применения декораторов.

## 1. Что такое декораторы?

Декораторы в Python — это функции, которые оборачивают другие функции, добавляя им новое поведение перед или после их выполнения. Декораторы позволяют:

- Добавлять функции логирования.
- Выполнять измерение времени выполнения.
- Реализовывать кэширование результатов.
- Проверять авторизацию, доступ, а также реализовывать другие задачи.

## 2. Основной синтаксис декораторов

### Пример простого декоратора

Давайте начнем с простого примера.

```python
def my_decorator(func):
    def wrapper():
        print("Что-то делаю перед вызовом функции")
        func()  # Вызов оригинальной функции
        print("Что-то делаю после вызова функции")
    return wrapper # Круглые скобки не добавляем, тк нам не нужно чтоб эта ф-ция здесь выполнилась, нужно только ее передать как объект, а не её результат. Это позволяет другим частям кода вызвать wrapper позже, когда это будет необходимо.

@my_decorator
def say_hello():
    print("Привет!")

say_hello()
```

### Объяснение кода:
1. **Декоратор**: Мы создаем функцию `my_decorator`, которая принимает другую функцию `func` в качестве параметра.
2. **Обертка**: Внутри `my_decorator` мы определяем функцию `wrapper`, добавляющую дополнительное поведение (вывод сообщений) перед и после вызова оригинальной функции `func()`.
3. **Использование**: Символ `@` перед `say_hello` эквивалентен записи `say_hello = my_decorator(say_hello)`. Это значит, что при вызове `say_hello()` будет выполнен код внутри `wrapper`.

**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет!
Что-то делаю после вызова функции
```

## 3. Декораторы с аргументами

Теперь рассмотрим, как создавать декораторы, которые могут работать с функциями, принимающими аргументы. Для этого мы используем `*args` и `**kwargs`.

### Пример:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        result = func(*args, **kwargs)  # Передаем аргументы в оригинальную функцию
        print("Что-то делаю после вызова функции")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Привет, {name}!")

greet("Мир")
```

### Объяснение кода:
- **`*args` и `**kwargs`**: Эти конструкции позволяют функции `wrapper` принимать любое количество позиционных аргументов  (`*args`) и именованных аргументов (`**kwargs`).
- **Вызов оригинальной функции**: При вызове `func(*args, **kwargs)`, мы передаем все полученные аргументы в оригинальную функцию `greet`.
  
**Вывод при запуске:**
```
Что-то делаю перед вызовом функции
Привет, Мир!
Что-то делаю после вызова функции
```

## 4. Отображение имен функций

Когда мы начинаем использовать декораторы, оригинальные имена функций могут быть потеряны. Чтобы сохранить метаданные, такие как имя и документацию, используйте `functools.wraps`.

### Пример:

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # Сохраняем метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        print("Что-то делаю перед вызовом функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция приветствует пользователя."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)   # Вывод: Эта функция приветствует пользователя.
```

### Объяснение кода:
- **`@functools.wraps(func)`**: Декоратор `wraps` обновляет функцию `wrapper`, чтобы она сохраняла имя и документацию оригинальной функции, что делает её более «прозрачной».

## 5. Примеры применения декораторов

### 5.1 Декоратор для логирования

Давайте рассмотрим декоратор для логирования вызовов функций:

```python
def logger(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__} с аргументами {args} и {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(3, 5)
print(f"Результат: {result}")
```

### Объяснение кода:
- Этот декоратор выводит имя вызываемой функции и её аргументы. При вызове `add(3, 5)`, он выведет, что функция была вызвана с указанными аргументами.

**Вывод при запуске:**
```
Вызов функции: add с аргументами (3, 5) и {}
Результат: 8
```

### 5.2 Декоратор для измерения времени выполнения

Теперь рассмотрим декоратор, который замеряет время выполнения функции.

```python
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Замеряем время начала
        result = func(*args, **kwargs)
        end_time = time.time()  # Замеряем время конца
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time:.4f} секунд")
        return result
    return wrapper

@timer
def compute_square(n):
    time.sleep(1)  # Имитация длительной операции
    return n ** 2

result = compute_square(10)
```

### Объяснение кода:
- В этом примере декоратор `timer` замеряет время на выполнение функции `compute_square`. Мы используем `time.sleep(1)` для имитации долгой операции, чтобы было видно время выполнения.

**Вывод при запуске:**
```
Время выполнения функции compute_square: 1.0010 секунд
```

## Заключение

Сегодня мы изучили, что такое декораторы в Python, как их создавать, использовать параметры `*args` и `**kwargs`, а также рассмотрели несколько практических примеров. 

Декораторы позволяют легко добавлять общее поведение ко многим функциям без дублирования кода, что делает ваш код более чистым и управляемым.


Итак мы осветили подробно концепцию декораторов, их создание и использование, включая работу с аргументами.
___






### Декораторы в PyTest
— это мощный инструмент для упрощения и улучшения процесса тестирования в Python. Они позволяют структурировать тесты, добавлять поведение и переопределять параметры, без необходимости создания новых функций или классов. В этой лекции мы рассмотрим основные декораторы, предоставляемые PyTest, и покажем примеры их использования.

---

# Лекция: Декораторы в PyTest

## Введение

Сегодня мы обсудим использование декораторов в библиотеке PyTest для тестирования ваших приложений на Python. Декораторы в PyTest позволяют управлять поведением тестов, например, для повторного запуска, настройки среды выполнения, управления зависимостями и т.д.

### Цели лекции:
- Понять, что такое декораторы в PyTest.
- Изучить основные декораторы и их применение.
- Рассмотреть примеры использования декораторов для улучшения тестирования.

## 1. Основы PyTest

Перед тем как углубляться в декораторы, давайте коротко вспомним, что такое PyTest. PyTest — это популярная библиотека для написания тестов в Python, которая поддерживает простые тесты, сложные функциональные тесты и интеграционные тесты.

### Установка PyTest

Если у вас еще не установлен PyTest, его можно установить через pip:

```bash
pip install pytest
```

## 2. Основные декораторы PyTest

### 2.1 `@pytest.mark.parametrize`

Этот декоратор используется для параметризации тестов, позволяя вам запускать один и тот же тест с различными наборами входных данных.

#### Пример:

```python
import pytest

@pytest.mark.parametrize("input, expected", [
    (1, 2),
    (2, 3),
    (3, 4)
])
def test_add_one(input, expected):
    assert input + 1 == expected
```

### Объяснение:
- **`@pytest.mark.parametrize`**: Декоратор принимает два параметра: имя аргументов и список значений. В данном случае `input` и `expected` будут переданы в тест `test_add_one` как параметры.
- **Запуск теста**: PyTest запустит `test_add_one` трижды: с (1, 2), (2, 3) и (3, 4).

### 2.2 `@pytest.mark.skip` и `@pytest.mark.skipif`

Эти декораторы позволяют пропускать тесты. `@pytest.mark.skip` всегда пропускает тест, тогда как `@pytest.mark.skipif` пропускает его при выполнении определенного условия.

#### Пример:

```python
import pytest

@pytest.mark.skip(reason="Тест временно отключен")
def test_func_1():
    assert True

@pytest.mark.skipif(1 + 1 == 2, reason="Пропускаем, когда 1 + 1 равно 2")
def test_func_2():
    assert False  # Этот тест не будет выполнен
```

### Объяснение:
- **`@pytest.mark.skip`**: Тест `test_func_1` полностью пропускается, и PyTest выведет сообщение о причине.
- **`@pytest.mark.skipif`**: Тест `test_func_2` будет пропущен, поскольку условие `1 + 1 == 2` истинно.

### 2.3 `@pytest.mark.xfail`

Этот декоратор позволяет пометить тест, который ожидается как неуспешный. Если тест не проходит, это не считается ошибкой.

#### Пример:

```python
import pytest

@pytest.mark.xfail
def test_func_xfail():
    assert False  # Ожидается, что этот тест завершится с ошибкой
```

### Объяснение:
- **`@pytest.mark.xfail`**: Если тест `test_func_xfail` завершится с ошибкой, PyTest отобразит это, но не пометит тест как провалившийся.

### 2.4 `@pytest.fixture`

Этот декоратор используется для создания "фабрик" для тестов, позволяя выполнять общие настройки, которые могут использоваться в нескольких тестах.

#### Пример:

```python
import pytest

@pytest.fixture
def sample_data():
    return {"key": "value"}

def test_data(sample_data):
    assert sample_data["key"] == "value"
```

### Объяснение:
- **`@pytest.fixture`**: Функция `sample_data` создаёт данные, которые могут быть использованы в тестах. PyTest автоматически находит любые функции, помеченные этим декоратором, и передает их в тесты, в которых они фигурируют в качестве аргументов.
  
Когда вы вызываете тест, который нуждается в `sample_data`, PyTest сначала выполнит функцию `sample_data`, а затем передаст результат в тест:

```python
def test_data(sample_data):
    assert sample_data["key"] == "value"  # Проверка, что данные возвращаются корректно
```

Такой подход позволяет удобно использовать общие ресурсы и настраивать их один раз в месте, а не дублировать код в каждом тесте.

### 2.5 `@pytest.mark.usefixtures`

Этот декоратор позволяет вам использовать фикстуры, даже если вы не собираетесь напрямую передавать их в тестовую функцию.

#### Пример:

```python
import pytest

@pytest.fixture
def prepare_data():
    return {"key": "value"}

@pytest.mark.usefixtures("prepare_data")
def test_data(prepare_data):
    assert prepare_data["key"] == "value"
```

### Объяснение:
- **`@pytest.mark.usefixtures`**: В этом примере фикстура `prepare_data` используется в тесте `test_data`, даже если сама фикстура не передаётся как аргумент в функцию теста. Это полезно, когда вы хотите применять фикстуру к нескольким тестам сразу.

### 2.6 Декораторы для долговременных тестов

Вы также можете создавать ваши собственные декораторы, используя функциональность PyTest. Например, вы можете создать декоратор для управления состоянием теста или для повторного запуска при сбоях.

#### Пример:

```python
import pytest

def retry(test):
    """Декоратор для повторного выполнения теста при сбое."""
    def wrapped(*args, **kwargs):
        for _ in range(3):  # Повторяем тест трижды
            try:
                return test(*args, **kwargs)
            except Exception as e:
                print(f"Тест не прошел: {str(e)}. Повторяем...")
        pytest.fail("Тест провалился после трех попыток.")
    return wrapped

@retry
def test_something():
    assert False  # Этот тест намеренно неуспешен
```

### Объяснение:
- В этом примере мы создали собственный декоратор `retry`, который позволяет повторно запускать тест до трех раз, если он завершается ошибкой. Если все три попытки завершаются неудачно, тест считается провалившимся.

## Заключение

В ходе лекции мы рассмотрели основные декораторы в PyTest и их назначение. 

### Основные моменты:

- **`@pytest.mark.parametrize`**: Позволяет запускать один тест с разными параметрами.
- **`@pytest.mark.skip`** и **`@pytest.mark.skipif`**: Используются для пропуска тестов.
- **`@pytest.mark.xfail`**: Позволяет пометить ожидаемо неуспешные тесты.
- **`@pytest.fixture`**: Создает общие ресурсы, которые могут использоваться в нескольких тестах.
- **`@pytest.mark.usefixtures`**: Позволяет явно использовать фикстуры в тестах без передачи их как аргументов.

Вы также узнали, как создавать собственные декораторы для повторного выполнения тестов или любой другой функциональности в вашей программной среде.
_________________________________
https://rutube.ru/video/dc14a896bc2d4cfc072183931856e20a/?r=wd
```
# Декораторы функций
def func_decorator(func):
    def wrapper():
        print("------ что-то делаем перед вызовом функции ------")
        func()
        print("------ что-то делаем после вызова функции ------")
    return wrapper()
#
#
# def some_func():
#     print("Вызов функции some_func")
#
#
#
# some_func()

# f = func_decorator(some_func)
# f

#
# some_func = func_decorator(some_func)
# some_func

##########################
# def func_decorator(func):
#     def wrapper(title):
#         print("------ что-то делаем перед вызовом функции ------")
#         func(title)
#         print("------ что-то делаем после вызова функции ------")
#     return wrapper
# def some_func(title):
#     print(f"title = {title}")
#
# some_func = func_decorator(some_func)
# some_func("Python навсегда!")


################################
def func_decorator(func):
    def wrapper(*args, **kwargs):
        print("------ что-то делаем перед вызовом функции ------")
        func(*args, **kwargs)
        print("------ что-то делаем после вызова функции ------")
    return wrapper


def some_func(title, tag):
    print(f"title = {title}, tag = {tag}")
    return f"<{tag}>{title}</{tag}>"

some_func = func_decorator(some_func)
some_func("Python навсегда!", "h1")

################################

# def func_decorator(func):
#     def wrapper(*args, **kwargs):
#         print("------ что-то делаем перед вызовом функции ------")
#         func(*args, **kwargs)
#         print("------ что-то делаем после вызова функции ------")
#         # return res
#
#     return wrapper
#
#
# def some_func(title, tag):
#     print(f"title = {title}, tag = {tag}")
#     return f"<{tag}>{title}</{tag}>"
#
#
# some_func = func_decorator(some_func)
# res = some_func("Python навсегда!", "h1")
# print(res)

################################

# def func_decorator(func):
#     def wrapper(*args, **kwargs):
#         print("------ что-то делаем перед вызовом функции ------")
#         res = func(*args, **kwargs)
#         print("------ что-то делаем после вызова функции ------")
#         return res
#
#     return wrapper
#
#
# def some_func(title, tag):
#     print(f"title = {title}, tag = {tag}")
#     return f"<{tag}>{title}</{tag}>"
#
#
# some_func = func_decorator(some_func)
# res = some_func("Python навсегда!", "h1")
# print(res)
# #################################
# import time
#
# def test_time(func):
#     def wrapper(*args, **kwargs):
#         st = time.time()
#         res = func(*args, **kwargs)
#         et = time.time()
#         dt = et - st
#         print(f"Время работы: {dt} сек")
#         return res
#
#     return wrapper
#
#
# def get_nod(a, b):
#     while a != b:
#         if a > b:
#             a -= b
#         else:
#             b -= a
#     return a
#
#
# def get_fast_nod(a, b):
#     if a < b:
#         a, b = b, a
#     while b:
#         a, b = b, a % b
#
#     return a
#
#
# get_nod = test_time(get_nod)
# get_fast_nod = test_time(get_fast_nod)
#
# res = get_nod(2, 1000000)
# res2 = get_fast_nod(2, 1000000)
# print(res, res2)

```
Предположим, у нас есть функция, которая называется func_decorator, и она будет принимать один параметр с именем func. Этот параметр будет ссылкой на некую функцию.
def func_decorator(func):
А внутри вот этой функции func_decorator будет ещё одна функция с именем wrapper. Это внутренняя функция может выполнить некиe команды до вызова вот этой вот функции func и некиe команды после вызова этой функции func.
Собственно ради этого мы её и описали. То есть функция wrapper, она не просто вызывает вот эту вот функцию func, ссылку на которую мы передаём, но и ещё дополнительно делает некие операции до её вызова и после её вызова.
Ну, соответственно, вот эта вот внешняя функция, func_decorator, должна вернуть ссылку на внутреннюю функцию. И наш декоратор в самом простом варианте, в общем-то, готов. 
def func_decorator(func):
    def wrapper():
        print("------ что-то делаем перед вызовом функции ------")
        func()
        print("------ что-то делаем после вызова функции ------")
    return wrapper()

Теперь мы можем с вами объявить некоторую стороннюю функцию, пусть она называется так вот:  
some_func()
def some_func():
    print("Вызов функции some_func")
и просто выводит в консоль некоторое сообщение ("Вызов функции some_func"). Если мы вызовем эту функцию Самфанк вот просто вот так вот через её имя, 
some_func()
то мы соответственно в консоли увидим вот эту вот строчку ("Вызов функции some_func"). То есть в принципе тут ничего особенного и нету.
Но мы можем вызвать эту же самую функцию и по-другому, используя вот эту функцию, func_decorator. Давайте это сделаем. Значит, вот здесь вот я сделаю следующим образом: определю некую переменную F, которая будет ссылаться на вот эту вот внутреннюю функцию ропер. А в качестве аргумента вот этого func_decorator мы, соответственно, передадим ссылку на вот эту вот нашу функцию some_func()
f = func_decorator(some_func())
f()
Ну а дальше вместо вот этого вот имени сам функ мы напишем F просто. Запустим нашу программу и смотрите, что у нас получилось. Мы не просто вызвали вот эту функцию сам функ, но что-то ещё сделали до её вызова и после её вызова. То есть вот эти вот строчки, вот всё, что мы здесь вот с вами написали, по сути работает следующим образом.

![image](https://github.com/user-attachments/assets/e7cfca8b-5697-4f9c-8ca2-4e3a121b2f5c)


