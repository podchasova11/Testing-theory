**Важные метрики покрытия** подробно и структурно. Эти метрики часто **важнее, чем покрытие кода**, так как они фокусируются на требованиях, пользователе и рисках — то есть на том, *что* и *почему* мы тестируем.

---

### 1. Покрытие требований (Requirements Coverage)
**Суть:** Насколько полно тестовый набор проверяет все формальные требования к системе. Это связь между миром разработки и миром бизнеса.

**Как измеряется:**
*   **Метрика:** `(Количество проверенных требований / Общее количество требований) * 100%`.
*   **Механика:** Каждому тест-кейсу или автотесту ставится в соответствие одно или несколько **идентификаторов требований** (например, `REQ-1.2`, `FUNC-USER-LOGIN`). В системах управления тестированием (TestRail, Qase, Zephyr) или ALM-системах (Jira + плагины) строится матрица прослеживаемости (Traceability Matrix), которая наглядно показывает, какие требования покрыты тестами, а какие — нет.

**Пример:**
> **Требование REQ-5:** *"Пользователь может восстановить пароль, указав email. На указанный email должно прийти письмо со ссылкой для сброса".*
> **Тесты:** `TC-101: Восстановление с валидным email`, `TC-102: Восстановление с невалидным email`, `TC-103: Проверка формата письма`.
> **Покрытие:** Требование REQ-5 покрыто тремя тестами.

**Плюсы:**
*   **Доказуемость:** Легко продемонстрировать заказчику или аудитору, что все оговоренные функции проверены.
*   **Фокус на цели:** Не позволяет "забыть" протестировать какую-то обязательную функцию.
*   **Основа для приемочного тестирования (UAT).**

**Минусы:**
*   **Качество требований:** Если требования написаны размыто или неполно, метрика теряет смысл.
*   **"Коробочное" мышление:** Может упустить сценарии, не описанные явно в требованиях, но очевидные с точки зрения пользователя.

---

### 2. Покрытие сценариев использования / Пользовательских историй (Use Case / User Story Coverage)
**Суть:** Оценка того, насколько полно протестированы ключевые пути взаимодействия пользователя с системой. Это переход от "проверки функций" к "проверке поведения".

**Как измеряется:**
*   Для каждого **Use Case** (с основным и альтернативными потоками) или **User Story** создается набор **сквозных (end-to-end) тестов** или интеграционных тестов.
*   **Метрика:** Покрытие можно оценивать качественно (все основные потоки покрыты) или количественно (например, % завершенных сценариев от запланированных к тестированию).
*   **Подход:** Составляется карта пользовательских путешествий (User Journey Map), и для каждого шага на карте определяется наличие тестов.

**Пример (User Story):**
> *"Как зарегистрированный пользователь, я хочу добавить товар в корзину, чтобы потом его купить".*
> **Сценарии для покрытия:**
> 1.  Добавление товара из каталога.
> 2.  Добавление товара со страницы товара.
> 3.  Добавление нескольких единиц одного товара.
> 4.  Проверка, что корзина обновляется без перезагрузки страницы (если заявлено).
> 5.  Добавление товара, которого нет в наличии (обработка ошибки).

**Плюсы:**
*   **Ориентация на ценность:** Тестируется то, что реально важно для пользователя.
*   **Выявление проблем интеграции:** Сквозные сценарии лучше всего ловят баги на стыке модулей.
*   **Основа для регрессионного тестирования критичного функционала.**

**Минусы:**
*   **Сложность поддержки:** Сквозные тесты (особенно UI) хрупкие и медленные.
*   **Неполнота:** Охватить все возможные вариации сценариев невозможно.

---

### 3. Покрытие данных (Data Coverage)
**Суть:** Оценка того, насколько разнообразны и репрезентативны тестовые данные. Код может быть покрыт на 100%, но работать неправильно на определенных данных.

**Как измеряется:**
*   **Классы эквивалентности и граничные значения:** Метрикой служит количество протестированных классов/границ. Например, для поля "Возраст" (18-99) нужно проверить: 17 (невалидная граница), 18, 19 (валидные границы), 50 (срединное значение), 99, 100 (невалидная граница).
*   **Комбинаторное покрытие:** Используются техники вроде **Pairwise (парное тестирование)**, чтобы покрыть наиболее вероятные комбинации входных параметров.
*   **Покрытие состояний данных:** Тестирование того, как система ведет себя с данными в разных состояниях (новые, обработанные, архивные, удаленные).

**Пример (Комбинаторное покрытие):**
> Форма с тремя полями: **Тип доставки** (Курьер, Самовывоз), **Оплата** (Карта, Наличные), **Срочность** (Стандарт, Экспресс).
> Полный перебор — 2x2x2 = 8 тестов. **Pairwise** подберет оптимальный набор (обычно 4-5 тестов), где каждая пара значений (Курьер-Карта, Курьер-Стандарт и т.д.) встретится хотя бы раз.

**Плюсы:**
*   **Эффективность:** Позволяет найти баги, связанные со специфичными данными, при меньшем количестве тестов.
*   **Систематичность:** Заставляет задуматься о разнообразии входных данных, а не писать тесты "на однотипных данных".

**Минусы:**
*   **Сложность генерации:** Требует навыков и иногда специальных инструментов для создания данных и комбинаций.
*   **Рост объема:** Полное покрытие всех комбинаций данных (как и путей) часто невозможно.

---

### 4. Покрытие рисков (Risk Coverage)
**Суть:** Самый стратегический вид покрытия. Оценка того, насколько тестовые усилия сконцентрированы на самых критичных для бизнеса и наиболее "багоопасных" областях системы.

**Как измеряется:**
1.  **Проводится анализ рисков:** Совместно с бизнес-аналитиками, архитекторами и разработчиками составляется **матрица рисков**.
2.  **Ранжирование:** Каждому модулю/функции присваивается приоритет на основе двух критериев:
    *   **Вероятность** дефекта (сложность, изменения в коде, компетенция разработчика).
    *   **Влияние** дефекта на бизнес (финансовые потери, репутационные риски, безопасность).
3.  **Распределение ресурсов:** На модули с **высокой вероятностью и высоким влиянием** выделяется больше всего тестовых ресурсов (время, глуби тестирования, виды тестирования).
4.  **Метрика:** Отчет о том, какой процент тестового времени/кейсов был потрачен на модули с высоким/средним/низким риском. Цель — чтобы **высокорисковые модули были протестированы наиболее тщательно**.

**Пример (Матрица рисков):**
| Модуль | Вероятность (1-3) | Влияние (1-3) | Уровень риска (В*В) | Стратегия тестирования |
| :--- | :---: | :---: | :---: | :--- |
| **Оплата транзакций** | 3 (сложная логика) | 3 (потеря денег) | **9 (КРИТИЧЕСКИЙ)** | Глубокое тестирование (MC/DC), нагрузочное, безопасность |
| **Каталог товаров** | 2 (часто меняется) | 2 (плохой UX) | **4 (СРЕДНИЙ)** | Регрессия, проверка UI |
| **Страница "О компании"** | 1 (стабильна) | 1 (опечатка) | **1 (НИЗКИЙ)** | Санти-чек или не тестируется |

**Плюсы:**
*   **Максимизация ROI тестирования:** Фокус на том, что важнее всего.
*   **Обоснованность решений:** Можно аргументировать, почему на одни модули пишут 100 автотестов, а на другие — 10.
*   **Превентивность:** Помогает выявить рискованные зоны до начала тестирования.

**Минусы:**
*   **Субъективность:** Оценка вероятности и влияния может быть субъективной.
*   **Требует экспертизы:** Нужно глубокое понимание продукта и бизнеса.

---

### 5. Покрытие среды/конфигураций (Environment/Configuration Coverage)
**Суть:** Актуально для кроссплатформенных и десктопных приложений. Оценка того, насколько приложение протестировано на всех заявленных платформах, браузерах, устройствах, версиях ОС, разрешениях экранов и конфигурациях.

**Как измеряется:**
*   **Матрица конфигураций:** Составляется таблица поддерживаемых окружений.
*   **Метрика:** `(Протестированные конфигурации / Все необходимые конфигурации) * 100%`.
*   **Практика:** Критические сценарии (логин, оплата) должны быть покрыты на всех основных конфигурациях. Менее важные — на репрезентативной выборке.

**Пример (Веб-приложение):**
> **Цель:** Покрытие 100% для Chrome, Firefox, Safari последних двух версий на Windows, macOS, iOS, Android.
> **Реальность:** 80% тестов на Chrome + Windows (основная среда), ключевые сценарии — на всех комбинациях из матрицы.

**Плюсы:** Гарантия, что продукт будет работать у конечных пользователей.
**Минусы:** Огромные трудозатраты. Решается через **автоматизацию на Selenium Grid/BrowserStack/Sauce Labs** и стратегию разумной достаточности.

### **Как это все работает вместе? Стратегический взгляд**

Идеальный подход — **комбинация метрик**:
1.  **На основе анализа рисков** определяем, **что** тестировать интенсивнее.
2.  **Покрытие требований** гарантирует, что мы ничего не упустили из контракта.
3.  **Покрытие сценариев использования** обеспечивает проверку работоспособности продукта с точки зрения пользователя.
4.  **Покрытие данных** и **кода** (ветвей) дает глубину проверки внутри каждого модуля.
5.  **Покрытие конфигураций** подтверждает работу на всех необходимых платформах.

Таким образом, **покрытие кода (например, ветвей) — это тактическая, низкоуровневая метрика.** А **покрытие требований, рисков и сценариев — это стратегические, бизнес-ориентированные метрики**, которые должны быть первичны при планировании тестирования.

___________________________________________
_________________________________________

Для оценки результатов работы группы тестирования используют
метрики покрытия (Coverage criteria) или полноты. Метрики покрытия позволяют оценить охват объекта тестирования тестами и выявить слабые места, где покрытие тестами минимально. Для оценки
покрытия можно воспользоваться следующими метриками.

Метрики покрытия (coverage criteria) — это ключевой инструмент для объективной оценки качества тестирования. Они позволяют перейти от субъективных оценок "мы хорошо протестировали" к измеримым данным.

Описание точно отражает суть: **оценить охват и выявить слабые места**.

Систематизируем основные метрики покрытия, которые используются на практике, от простых к более сложным.

### Основные виды метрик покрытия кода (Code Coverage)

Это самые распространенные и часто автоматически собираемые метрики (с помощью инструментов вроде JaCoCo для Java, Coverage.py для Python, Istanbul для JavaScript и т.д.).

1.  **Покрытие операторов (Statement Coverage)**
    *   **Что измеряет:** Процент выполненных операторов (строк кода) от общего их числа.
    *   **Цель:** Убедиться, что каждая строка кода была выполнена хотя бы раз.
    *   **Пример:** Если в функции 10 строк, а тесты выполнили 8, покрытие операторов = 80%.
    *   **Плюсы:** Простота сбора и понимания.
    *   **Минусы:** Очень слабая метрика. Можно выполнить все строки, но пропустить важные комбинации условий.

2.  **Покрытие решений/ветвей (Branch/Decision Coverage)**
    *   **Что измеряет:** Процент пройденных ветвей (исходов) от всех возможных в управляющих конструкциях (`if`, `else`, `switch`, `while`, `for`).
    *   **Цель:** Убедиться, что и истинная (`true`), и ложная (`false`) ветка каждого условия были протестированы.
    *   **Пример:** Для кода `if (x > 0) { A } else { B }` нужно два теста: один с `x > 0` (ветка A), другой с `x <= 0` (ветка B).
    *   **Плюсы:** Мощнее, чем покрытие операторов. Выявляет неохваченные логические пути.
    *   **Минусы:** Не учитывает сложные условия внутри одного решения (см. следующую метрику).

3.  **Покрытие условий (Condition Coverage)**
    *   **Что измеряет:** Процент возможных исходов для каждого **простого условия** внутри составного логического выражения.
    *   **Цель:** Убедиться, что каждое элементарное условие принимало значения `true` и `false`.
    *   **Пример:** Для кода `if (A && B) { ... }` простые условия — это `A` и `B`. Нужны тесты, где:
        *   `A = true`, `B = false`
        *   `A = false`, `B = true`
        *   (идеально также `true/true` и `false/false`).
    *   **Плюсы:** Более тщательная проверка логики.
    *   **Минусы:** Выполнение всех условий не гарантирует покрытия всех решений.

4.  **Комбинированное покрытие решений и условий (Modified Condition/Decision Coverage - MC/DC)**
    *   **Что измеряет:** Усиленная версия покрытия условий. Требует, чтобы каждое простое условие влияло на итоговое решение независимо.
    *   **Цель:** Обеспечить высокий уровень проверки сложной логики, особенно критичной для безопасности (авионика, медицина).
    *   **Пример:** Для `if (A && B)` нужно показать, что:
        *   При изменении только `A` (с `true` на `false` при фиксированном `B = false`) меняется результат всего решения.
        *   При изменении только `B` (с `true` на `false` при фиксированном `A = false`) меняется результат всего решения.
    *   **Плюсы:** Очень мощная и надежная метрика для критичных систем.
    *   **Минусы:** Сложность в расчете и достижении 100%. Часто избыточна для бизнес-приложений.

5.  **Покрытие путей (Path Coverage)**
    *   **Что измеряет:** Процент всех возможных уникальных путей выполнения через функцию или модуль (с учетом циклов).
    *   **Цель:** Самый исчерпывающий вид покрытия.
    *   **Пример:** В функции с двумя `if` подряд может быть 2x2 = 4 возможных пути.
    *   **Плюсы:** Максимально возможная проверка.
    *   **Минусы:** На практике часто не достижим из-за экспоненциального роста числа путей (циклы создают бесконечное число путей). Скорее теоретический идеал.

### Другие важные метрики покрытия (не только код)

Покрытие — это не только о строках кода. Оценивать можно разные аспекты:

*   **Покрытие требований (Requirements Coverage):**
    *   **Что измеряет:** Процент реализованных и протестированных функциональных требований.
    *   **Инструмент:** Связывание тест-кейсов с требованиями в системах управления тестированием (TestRail, Zephyr и т.д.).

*   **Покрытие сценариев использования/UI (Scenario/UI Coverage):**
    *   **Что измеряет:** Охват ключевых пользовательских сценариев (user stories, user journeys).
    *   **Важно:** Даже при 100% покрытии кода можно пропустить критичный для пользователя сценарий.

*   **Покрытие данных (Data Coverage):**
    *   **Что измеряет:** Насколько разнообразны и репрезентативны тестовые данные (валидные, граничные, невалидные).

*   **Покрытие рисков (Risk Coverage):**
    *   **Что измеряет:** Насколько тестовые усилия сфокусированы на наиболее рискованных и критичных для бизнеса модулях.

### **Как правильно использовать метрики покрытия: важные предостережения**

1.  **Не цель, а инструмент:** 100% покрытие — **не гарантия** отсутствия багов. Оно показывает, что код был выполнен, но не проверяет корректность результата.
2.  **Качество тестов важнее процента:** Бессмысленный тест, который ничего не проверяет (`assert true`), даст покрытие, но не найдет дефектов.
3.  **"Ловушка" высоких процентов:** Команда может начать "гнаться за цифрами", создавая бесполезные тесты вместо тестирования сложной логики.
4.  **Разные метрики для разных задач:**
    *   Для стартапа или веб-приложения часто достаточно **покрытия ветвей > 80%** как хорошего индикатора.
    *   Для модулей с высокой бизнес-логикой важно **покрытие условий**.
    *   Для жизненно важных систем (автопилот, банковские транзакции) требуется **MC/DC**.

### **Практический вывод**

1.  **Начните с покрытия ветвей (Branch Coverage)** — это лучший компромисс между сложностью и полезностью.
2.  Используйте метрики как **маяк для поиска "белых пятен"**, а не как KPI для наказания.
3.  **Комбинируйте** метрики покрытия кода с покрытием требований и сценариев.
4.  **Анализируйте отчеты о покрытии** регулярно, чтобы находить непротестированные участки кода (часто это "убойные" `else` или обработчики ошибок).

**Итог:** Метрики покрытия — это мощный инструмент для анализа и улучшения процесса тестирования, но их нужно применять с умом, понимая их ограничения и смысл.
