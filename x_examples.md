Дан кортеж: tpl = (1, 2, 3, [1,2,3], 5). Как все знают, кортеж - это неизменяемый тип данных. Изменится ли его содержимое после выполнения команды tpl[3].append(4)?

```
tpl = (1, 2, 3, [1, 2, 3], 5)
print(id(tpl))  # Сохраняем ID кортежа

tpl[3].append(4)  # Меняем список внутри кортежа
print(tpl)       # Содержимое кортежа изменится

print(id(tpl))  # ID кортежа останется тем же

```

Да, кортеж `tpl` сам по себе остаётся неизменным, поскольку кортежи являются неизменяемыми структурами данных в Python. Однако внутри кортежа может содержаться изменяемый объект, такой как список. 

В нашем примере `tpl = (1, 2, 3, [1,2,3], 5)` — четвёртым элементом является список `[1, 2, 3]`. После выполнения команды `tpl[3].append(4)` вы добавите элемент `4` в этот список. Таким образом, содержимое списка изменится и станет `[1, 2, 3, 4]`. 

Однако сам кортеж `tpl` останется прежним. То есть его структура не изменится, вы всё равно будете иметь доступ к старому списку через `tpl[3]`, который теперь будет равен `[1, 2, 3, 4]`.


### задача 
с собеса на изменяемые/неизменяемые типы данных:
- **Что произойдет** , если в список, лежащий внутри кортежа добавить еще один элемент:
```
my_tuple = ([1, 2, 3],)
my_tuple[0].append(4)
print(my_tuple)
```
а также объяснить, что означает последняя запятая
в кортеже ([1, 2, 3],)

_______________________ 

В Python кортежи и списки — это два разных типа данных с различными характеристиками. Чтобы понять, что произойдет при добавлении элемента в список, находящийся внутри кортежа, разберем каждую часть по отдельности.

### Основные характеристики:
1. **Кортеж (tuple)**:
   - Неизменяемый (immutable): После создания кортежа вы не можете изменять его содержимое (добавлять, удалять или изменять элементы).
   - Определяется с помощью круглых скобок `()`.

2. **Список (list)**:
   - Изменяемый (mutable): Вы можете изменять содержимое списка, добавлять и удалять элементы.
   - Определяется с помощью квадратных скобок `[]`.

### Пример:
Рассмотрим следующий код:

```python
my_tuple = ([1, 2, 3],)
```

Здесь `my_tuple` является кортежем, содержащим один элемент — список `[1, 2, 3]`.

### Добавление элемента:
Если вы добавите элемент в список внутри кортежа, то это вполне возможно, потому что список изменяемый. Например, так:

```python
my_tuple[0].append(4)
```

Теперь в списке, который хранится внутри кортежа, будет элемент `4`. Если проверить содержимое кортежа, то оно будет выглядеть так:

```python
print(my_tuple)  # Вывод: ([1, 2, 3, 4],)
```

### Суть процесса:
- Вы не изменяете сам кортеж, а изменяете содержимое списка, который является элементом этого кортежа. Кортеж остается неизменным в том смысле, что вы не можете изменить сам кортеж, но внутренние объекты, такие как списки, могут изменяться.

### Итог:
Таким образом, можно добавлять элементы в список внутри кортежа, но вы не сможете изменить сам кортеж (например, добавлять или удалять элементы из кортежа). Это ключевая разница между изменяемыми и неизменяемыми структурами данных в Python.


Понимание ссылок в Python, особенно в контексте кортежей и изменяемых объектов, таких как списки, — это важный аспект работы с данными в этом языке. Давайте подробнее разберемся с тем, как работают ссылки в кортежах.

### Ссылки в Python

Когда мы говорим о ссылках в Python, мы имеем в виду, что переменные указывают на объекты в памяти, а не содержат данные непосредственно. Это означает, что переменные хранят ссылки на объекты (например, списки или кортежи), а не сами объекты.

#### Кортежи и ссылки

1. **Создание кортежа**:
   Когда вы создаете кортеж, например:
   ```python
   my_tuple = ([1, 2, 3],)
   ```
   В данном случае `my_tuple` содержит одну ссылку на список `[1, 2, 3]`, который находится в памяти.

2. **Изменение внутреннего списка**:
   Когда вы добавляете элемент к этому списку:
   ```python
   my_tuple[0].append(4)
   ```
   Вы изменяете сам список, находящийся по ссылке, на которую ссылается первый элемент кортежа. Кортеж по-прежнему содержит ссылку на тот же список — это означает, что данные в памяти изменяются, а ссылка в кортеже остается прежней.

3. **Кортеж остается неизменным**:
   Если бы вы попытались изменить сам кортеж, добавив в него новый элемент:
   ```python
   my_tuple += ([5],)  # Это вызовет ошибку, если взять его по другому
   ```
   Это не сработает, потому что кортежи — неизменяемые, и для изменения кортежа нужно создавать новый кортеж.

### Точки внимания

- **Изменяемые и неизменяемые типы**: Важно понимать, что когда кортеж содержит изменяемый тип (например, список), вы можете изменять этот внутренний изменяемый объект. Однако сам кортеж остается неизменяемым.

- **Ссылки на один и тот же объект**: Если вы создадите другой кортеж, который ссылается на тот же список, например:
  ```python
  another_tuple = (my_tuple[0],)
  ```
  Оба кортежа (`my_tuple` и `another_tuple`) содержат ссылки на один и тот же список. Изменение списка через один из кортежей повлияет на другой, поскольку оба кортежа ссылаются на один и тот же объект.

### Пример:

```python
my_tuple = ([1, 2, 3],)
another_tuple = (my_tuple[0],)

my_tuple[0].append(4)

print(my_tuple)       # Вывод: ([1, 2, 3, 4],)
print(another_tuple)  # Вывод: ([1, 2, 3, 4],)
```

В этом примере изменение списка в `my_tuple` отображается в `another_tuple`, так как они указывают на один и тот же объект.

### Заключение

Таким образом, ссылки в кортежах позволяют изменять содержимое вложенных изменяемых объектов, но сами кортежи не могут быть изменены. Это важно учитывать при проектировании программ, чтобы обеспечить правильное управление изменяемыми и неизменяемыми объектами. 


В Python последняя запятая в выражениях с кортежами имеет специальное значение. Давайте разберемся, что она обозначает.

### Кортежи и последняя запятая

Когда вы создаете кортеж, заключая элементы в круглые скобки, запятая, следуя после элемента, является тем, что фактически обозначает, что вы создаете кортеж. Если вы не добавите запятую, Python может не распознать это как кортеж. Рассмотрим несколько примеров:

1. **Кортеж с одним элементом**:
   Если вы хотите создать кортеж с единственным элементом, вы должны использовать запятую:
   ```python
   single_element_tuple = (1,)  # Это кортеж с одним элементом
   ```
   Если запятую не поставить, это будет просто число:
   ```python
   not_a_tuple = (1)  # Это не кортеж, это просто число 1
   ```

2. **Кортеж с несколькими элементами**:
   При создании кортежа с несколькими элементами запятая разделяет элементы:
   ```python
   my_tuple = (1, 2, 3)  # Это кортеж, содержащий три элемента
   ```

3. **Кортеж, содержащий изменяемый объект**:
   В вашем случае, когда вы пишете:
   ```python
   my_tuple = ([1, 2, 3],)  # Кортеж, содержащий один элемент — список
   ```
   То `([1, 2, 3],)` — это кортеж с одним элементом, которым является список `[1, 2, 3]`. Запятая нужна для того, чтобы Python понимал, что это именно кортеж.

### Почему важна запятая

Запятая позволяет Python отличать кортежи от других типов данных:

- **Одноелементный кортеж**: Запятая обязательна, чтобы указать, что это кортеж, а не просто выражение или значение.
- **Контекст**: В контексте компоновки и работы с кортежами запятая дает понять, что вы работаете с коллекцией, содержащей один или несколько элементов.

### Пример с изменением списка внутри кортежа

Если кортеж будет содержать изменяемый объект (например, список), и вы измените список, например так:
```python
my_tuple[0].append(4)
print(my_tuple)  # Вывод: ([1, 2, 3, 4],)
```
То вы увидите, что списки внутри кортежа изменяются, но структура самого кортежа остается неизменной и определяется его внутренним содержимым и запятой.

### Итог

Таким образом, последняя запятая в выражениях кортежей, как в `([1, 2, 3],)` и `([1, 2, 3, 4],)`, указывает на то, что это кортеж. Запятая после единственного элемента — это обязательное требование для создания одноэлементного кортежа в Python.

-------------------------------------------------------
«Флаки» (или **flaky tests**) — это тесты, которые периодически непредсказуемо проходят и не проходят, несмотря на то, что код приложения не изменяется. Это может вызвать недоверие к тестовому набору и затруднить выявление реальных проблем в приложении. Вот несколько ключевых моментов, которые стоит учесть при обсуждении «флаков» на собеседовании:

1. **Определение**:
   - Флаки тесты проявляют нестабильное поведение: они могут проходить в одних условиях и проваливаться в других без изменения функционала приложения.

2. **Причины возникновения**:
   - **Асинхронные условия**: Проблемы с синхронизацией в тестах, особенно при работе с асинхронными операциями.
   - **Зависимость от среды**: Факторы, влияющие на тесты, такие как изменения в сети, сервере или данных.
   - **Тестовые данные**: Использование нестабильных или зависимых от состояния данных, которые могут изменяться между запусками.
   - **Непредвиденные задержки**: Средства тестирования могут быть слишком быстрыми или медленными, что приводит к непоследовательным результатам.

3. **Последствия**:
   - Флаки могут привести к ложным срабатываниям, что заставляет команду тратить время на анализ проблем, которые не являются настоящими.
   - Уменьшение доверия к автоматизированному тестированию в целом, что может привести к игнорированию важных тестов.

4. **Подходы к решению**:
   - **Анализ и устранение причин**: Определить источники нестабильности и исправить их (например, улучшение синхронизации, фиксирование тестовых данных).
   - **Устойчивость тестов**: Разрабатывать тесты с учетом всех возможных переменных, чтобы снизить вероятность флаков.
   - **Использование повторных запусков**: Если тест провалился, повторное его выполнение может помочь выяснить, был ли это флаки.
   - **Документация**: Ведение учета флак-тестов и резервировать обсуждение результатов с командой для выявления и исправления основных причин.

5. **Примеры из практики**:
   - Подумай о примерах, когда ты сталкивался с флаками в своих проектах. Как ты идентифицировал их и что делал, чтобы решить проблему?

Обсуждение «флаков» на собеседовании покажет твою способность анализировать и управлять качеством тестов, а также понимание проблем, с которыми могут сталкиваться команды при автоматизации тестирования.
--------------------------------------------------------
_______________________________________________________Когда говорят о тестировании на **Python**, подразумевают использование языка для автоматизации тестирования приложений, написанных на Python или других языках. Python предоставляет множество библиотек и инструментов, которые могут помочь в создании, управлении и выполнении тестов. Вот несколько ключевых моментов, которые стоит обсудить при упоминании тестирования на Python на собеседовании:

### 1. Основные библиотеки для тестирования:

- **unittest**: Встроенная библиотека для создания и выполнения тестов. Она позволяет создавать тестовые классы и методы, а также включает поддержка тестовых наборов.
  
  Пример:
  ```python
  import unittest
  
  class MyTestCase(unittest.TestCase):
      def test_addition(self):
          self.assertEqual(1 + 1, 2)
  
  if __name__ == "__main__":
      unittest.main()
  ```

- **pytest**: Популярная библиотека тестирования, которая предлагает более гибкую и мощную систему для написания тестов. Поддерживает фикстуры, параметризацию и интеграцию с другими инструментами.

  Пример:
  ```python
  import pytest
  
  def test_addition():
      assert 1 + 1 == 2
  ```

- **doctest**: Позволяет включать тесты непосредственно в документацию функций, что полезно для проверки корректности кода в примерах.

  Пример:
  ```python
  def add(a, b):
      """
      >>> add(1, 2)
      3
      """
      return a + b
  
  if __name__ == "__main__":
      import doctest
      doctest.testmod()
  ```

### 2. Виды тестирования:

- **Модульное тестирование** (Unit Testing): Фокус на тестировании отдельных функций или методов. Используются `unittest` или `pytest`.

- **Интеграционное тестирование**: Проверка взаимодействия между различными модулями или компонентами.

- **Функциональное тестирование**: Проверка функциональности приложения. Можно использовать библиотеки, такие как `Selenium`, для тестирования веб-приложений.

- **Нагрузочное тестирование**: Проверяет, как приложение справляется с нагрузкой, например, с помощью `Locust`.

### 3. Автоматизация тестирования:

- **Контроль версий**: Делайте тесты частью вашего процесса CI/CD, используя инструменты, такие как GitHub Actions, GitLab CI или Jenkins.

- **Запуск тестов**: Используйте команды для автоматизации тестов, например, `pytest tests/`, чтобы запускать все тесты в вашей системе.

- **Отчетность**: Используйте плагины для pytest, такие как `pytest-html`, которые позволяют генерировать отчеты о тестировании.

### 4. Best Practices:

- **Чистота кода**: Следите за тем, чтобы тесты были легко читаемыми и поддерживаемыми.
  
- **Изолированность тестов**: Каждый тест должен быть независимым от других. Если один тест провалился, это не должно влиять на другие.

- **Mock-объекты**: Используйте библиотеки, такие как `unittest.mock`, для создания поддельных объектов и функций, чтобы изолировать тестируемый код от внешних зависимостей.

### 5. Примеры из практики:
Подготовь примеры тестов, которые ты писал на Python. Расскажи о сложностях, с которыми ты сталкивался, и как ты их решал. Это поможет продемонстрировать твои навыки и опыт.

Обсуждая тестирование на Python во время собеседования, важно показать своё понимание инструментов и методологий, чтобы подчеркивать свою квалификацию и готовность к решению различных задач. Удачи на собеседовании!

- **Вопрос с техсобеса Тиньков банк**, если вы отправляете баги разработчикам а они отправляют их в беклог и ничего не делают, как почистить этот беклог по каким принципам
### Управление беклогом — это важный аспект разработки программного обеспечения, особенно в контексте обеспечения качества и своевременной реакции на сообщения об ошибках. Если вы сталкиваетесь с ситуацией, когда отправленные баги не фиксируются и просто накапливаются в беклоге, можно применить несколько принципов и шагов для его очистки и более эффективного управления. Вот некоторые из них:

### 1. Приоритизация багов

- **Критичность и серьезность**: Оцените каждый баг на основе его влияния на пользователей и продукт. Можно создать матрицу для определения приоритета — высокую критичность (например, блокирующие или серьезные ошибки) следует решать в первую очередь.
- **Частота возникновения**: Баги, которые возникают часто, могут иметь больший приоритет по сравнению с редкими, даже если они менее критичны.

### 2. Регулярные обзоры беклога

- **Пересмотр беклога**: Установите регулярные заседания команды или рабочей группы для пересмотра существующих багов и их состояния. Обсуждайте, какие из них все еще актуальны, и удаляйте те, которые больше не имеют значения.
- **Обновление статусов**: Все баги должны иметь актуальные статусы. Если баг не будет решен в течение определенного времени, уточните его состояние и необходимость.

### 3. Использование метрик

- **Анализ метрик**: Собирайте метрики о времени, проведенном в беклоге, и времени, когда баги фиксируются. Если какие-то области постоянно остаются нерешенными, это может указывать на необходимость пересмотра приоритетов или процессов.
- **Выявление узких мест**: Определите общие причины, по которым баги остаются в беклоге. Например, это может быть нехватка ресурсов, недостаточная оценка приоритета или неправильные процессы.

### 4. Вовлечение команды

- **Общая ответственность**: Убедитесь, что команда разработки понимает важность устранения багов, а не только создания новых функций. Это может включать обсуждение качества на ежедневных утренних встречах или планировках спринтов.
- **Стимулирование участия**: Поощряйте разработчиков участвовать в исправлении багов, возможно, через внутренние конкурсы или выделение времени в спринтах для работы над исправлением ошибок.

### 5. Установление четких процессов

- **Определение процессов**: Установите четкие процессы для обработки багов, включая приемлемые сроки для решения. Каждый новый баг должен быть оценен и размещен в соответствующем приоритете.
- **Использование автоматизации**: Если возможно, используйте инструменты автоматизации для отслеживания и уведомления о статусах багов.

### 6. Обратная связь и коммуникация

- **Регулярная обратная связь**: Поддерживайте открытый каналы связи между командой разработки, тестирования и пользователями. Представляйте обновления по статусам исправлений багов.
- **Транспарентность**: Делитесь информацией о том, какие баги собираются решать, и их текущем статусе. Это поможет управлять ожиданиями и повысить доверие.

### 7. Очистка устаревших или нерелевантных багов

- **Удаление нерелевантных багов**: Если какие-то ошибки долгое время не фиксировались и не имеют ясных причин для их существования, рассмотрите возможность их удаления из беклога.
- **Стирание дубликатов**: Убедитесь, что в беклоге нет дублирующих багов. Слияние схожих багов может помочь сократить количество записей.

### Заключение

Эффективное управление беклогом требует постоянного внимания и регулярной работы со всей командой. Применяя вышеперечисленные принципы, вы сможете более эффективно очищать и поддерживать беклог в актуальном состоянии, что приведет к улучшению качества продукта и удовлетворенности пользователей. 

Ответственность за управление беклогом и очистку багов обычно лежит на следующих участниках команды:

1. **Product Owner (Владелец продукта)**: В основном отвечает за приоритизацию задач и принятие решений о том, какие баги должны быть отработаны в первую очередь. Они должны понимать бизнес-ценность каждого бага и его влияние на пользователей.

2. **Тимлид/Технический руководитель**: Часто участвует в определении приоритетов с технической точки зрения. Они могут оценивать сложность и временные затраты на исправление багов.

3. **QA-инженеры (Тестировщики)**: Их задача — выявлять, документировать и классифицировать баги. Они также могут предоставлять информацию о том, как часто баги возникают и как критичны они для пользователей.

4. **Разработчики**: Хотя основная ответственность за реализацию исправлений лежит на разработчиках, они также участвуют в обсуждении приоритетов и могут высказывать мнение о сложности исправления конкретных багов.

5. **Команда** в целом: Все участники команды могут вносить идеи по удалению, изменение приоритета и оценке задач в беклоге на общих встречах. 

Важно, чтобы у команды была четкая коммуникация и понимание приоритетов, чтобы эффективно справляться с багами и управлять их количеством в беклоге.


🔹 HTTP 403 предоставляет случай ошибки, отличный от HTTP 401: сервер возвращает HTTP 401, когда клиент не прошел аутентификацию, и подразумевает, то успешный ответ может быть возвращен после действительной аутентификации, а HTTP 403 означает, что клиенту не разрешен доступ к ресурсу, несмотря на предоставление аутентификации.



___________________________________________
🔹 При отправке POST-запроса важно указать тип отправляемого содержимого в теле запроса, чтобы сервер мог правильно интерпретировать тело запроса. Вы можете использовать типы MIME в заголовке Content-Type в HTTP-запросе, чтобы указать формат тела запроса
___________________________________________
Главная цель REST API - облегчить передачу и управление информацией между разными системами: создавать, читать, изменять, удалять (CRUD). REST API использует для этого стандартные HTTP-запросы: GET, POST, PUT, DELETE и другие.

🔹 REST API - это архитектурный стиль проектирования взаимодействия приложений.
🔹 HTTP - протокол, на основе которого работает REST API.

Отличие REST API от других видов API, таких как SOAP API, ftp и RPC, заключается в том, что REST API не имеет жестких правил и структур, и может быть использован с любым языком программирования - Java, Python, C++ и другие.

Из-за того, что REST API не имеет жестких правил и структур, и возникают спорные вопросы, связанные с его проектированием.
______________________________________________
🔹 ответ какого http метода можно кэшировать
Безопасные методы: Кеширование только запросов GET или HEAD
HTTP кеширование работает лишь для "безопасных" HTTP методов (таких как GET и HEAD). 
__________________________________________________
🔹 Базы данных отличаются от СУБД тем, что сами по себе представляют лишь файл на компьютере. Базы данных не умеют ничего делать с этими данными — только хранить. А вот СУБД уже предоставляют возможности по манипуляции ими. Электронные таблицы очень похожи на базы данных, но имеют большой недостаток: если несколько пользователей будут использовать одну таблицу одновременно, есть риск перезаписать данные друг поверх друга и потерять их.
___________________________________________

Что выведет данный запрос

SELECT teacher.surname, lesson.name 
FROM teacher 
INNER JOIN lesson ON teacher.id = lesson.teacher_id
WHERE teacher.age > 25;  

Выведет учителей и уроки, у всех учителей у кого возраст больше 25
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Петров  | Русский     |
| Сидоров | Физика      |
| Сидоров | Физика      |
+---------+-------------+

 Примеры популярных СУБД: Oracle, MySQL, Microsoft SQL Server, PostgreSQL.

 _____________________________________________________________

 каким термином называется автоматизированная последовательность шагов для создания проверки и отладки ПО? Ответ - Скрипт

 __________________________________________________

 что такое Message Broker
 Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.
 ______________________________________________________

 фильтрация данных в sql
 Предложение WHERE в SQL фильтрует данные на основе определенных условий , позволяя вам извлекать строки, которые соответствуют вашим критериям. Пример 1: Если вы хотите отфильтровать данные таблицы на основе определенных критериев, таких как пол, вы можете использовать виджет Select с требуемой опцией. SELECT * FROM users WHERE gender = {{Select1.

___________________________________________________________________

### Командная​ ​строка​ ​Ubuntu: ​команды​ ​bash

Рассмотрим основные команды консоли Ubuntu:

sudo
Промежуточная команда sudo (SuperUser DO — суперпользователь) позволяет запускать программы от имени администратора или root-пользователя.

Вы можете добавить sudo перед любой командой, чтобы запустить её от имени суперпользователя.

apt-get
Команда apt-get используется для работы с программными пакетами для установки программных пакетов (sudo apt-get install имя-пакета), обновления репозитория с пакетами (sudo apt-get update) и обновления пакетов, которые установлены в систему (sudo apt-get upgrade).

pwd
Команда pwd (print working directory — вывести рабочую директорию) показывает полное имя рабочей директории, в которой вы находитесь.

ls
Команда ls (list — список) выводит все файлы во всех папках рабочей директории.

С помощью ls -a можно вывести и скрытые файлы.

сd
Команда cd (change directory — изменить директорию) позволяет перейти в другую директорию.

Можно ввести как полный путь до папки, так и её название. Например, чтобы попасть в папку Files, лежащую в директории /user/home/Files, введите cd Files или cd /user/home/Files.

Чтобы попасть в корневую директорию, введите cd /.

cp
Команда cp (copy — копировать) копирует файл.

Например, cp file1 file2 скопирует содержимого файла file1 в file2.

Команда cp file /home/files скопирует файл с названием file в директорию /home/files.

mv
Команда mv (move — переместить) помогает перемещать файлы.

Также с помощью mv можно переименовывать файлы. Например, у нас есть файл file.txt. С помощью команды mv file.txt new_file.txt мы можем перенести его в ту же директорию, но у файла уже будет новое название new_file.txt.

rm
Команда rm (remove — удалить) удаляет файлы и каталоги.
_______________________________________________________

CSS - СЕЛЕКТОРЫ 

:nth-child(2) : Выберет второй дочерний элемент. :nth-child(2n) : Выберет все четные дочерние элементы (2-й, 4-й, 6-й, 8-й и так далее).

Так, команда rm file.txt удалит текстовый файл с названием file, а команда rm -r Files удалит директорию Files со всеми содержащимися в ней файлами.

mkdir
С помощью mkdir (make directory — создать директорию) можно создать новую директорию.

Так, команда mkdir directory создаст новую директорию с именем directory в текущей рабочей директории.

____________________________________________________________________

# Про токены, JSON Web Tokens (JWT), аутентификацию и авторизацию. Token-Based Authentication

`Last major update: 25.08.2020`

- Что такое авторизация/аутентификация
- Где хранить токены
- Как ставить куки ?
- Процесс логина
- Процесс рефреш токенов
- Кража токенов/Механизм контроля токенов
- Зачем все это ? JWT vs Cookie sessions

## Основа:
__Аутентификация(authentication, от греч. αὐθεντικός [authentikos] – реальный, подлинный; от αὐθέντης [authentes] – автор)__ - это процесс проверки учётных данных пользователя (логин/пароль). Проверка подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными в базе данных.

__Авторизация(authorization — разрешение, уполномочивание)__ - это проверка прав пользователя на доступ к определенным ресурсам.

Например, после аутентификации юзер _**sasha**_ получает право обращаться и получать от ресурса __"super.com/vip"__ некие данные. Во время обращения юзера _**sasha**_ к ресурсу __vip__ система авторизации проверит имеет ли право юзер обращаться к этому ресурсу (проще говоря переходить по неким разрешенным ссылкам)

1. Юзер c емайлом _**sasha_gmail.com**_ успешно прошел аутентификацию
2. Сервер посмотрел в БД какая роль у юзера
3. Сервер сгенерил юзеру токен с указанной ролью
4. Юзер заходит на некий ресурс используя полученный токен
5. Сервер смотрит на права(роль) юзера в токене и соответственно пропускает или отсекает запрос

Собственно п.5 и есть процесс __авторизации__.

*Дабы не путаться с понятиями __Authentication/Authorization__ можно использовать псевдонимы __checkPassword/checkAccess__(я так сделал в своей API)*

__JSON Web Token (JWT)__ — содержит три блока, разделенных точками: заголовок(__header__), набор полей (__payload__) и __сигнатуру__. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Пример подписанного JWT токена (после декодирования 1 и 2 блоков):
```
{ alg: "HS256", typ: "JWT" }.{ iss: "auth.myservice.com", aud: "myservice.com", exp: 1435937883, userName: "John Smith", userRole: "Admin" }.S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```

__Токены__ предоставляют собой средство __авторизации__ для каждого запроса от клиента к серверу. Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и __payload'e__. Токен в итоге хранится на клиенте и используется при необходимости __авторизации__ какого-либо запроса. Такое решение отлично подходит при разработке SPA.

При попытке хакером подменить данные в __header'ре__ или __payload'е__, токен станет не валидным, поскольку сигнатура не будет соответствовать изначальным значениям. А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

__access token__ - используется для __авторизации запросов__ и хранения дополнительной информации о пользователе (аля __user_id__, __user_role__ или еще что либо, эту информацию также называет __payload__). Все поля в __payload__ это свободный набор полей необходимый для реализации вашей частной бизнес логики. То бишь __user_id__ и __user_role__ не являются требованием и представляют собой исключительно частный случай. __Сам токен храним не в localStorage как это обычно делают, а в памяти клиентского приложения__ (что приводит к необходимости при каждом обновлении странички браузера запрашивать новую пару токенов).

__refresh token__ - выдается сервером по результам успешной аутентификации и используется для получения новой пары __access/refresh__ токенов. __Храним исключительно в httpOnly куке__.

Каждый токен имеет свой срок жизни, например __access__: 30 мин, __refresh__: 60 дней

__Поскольку токены(а данном случае access) это не зашифрованная информация крайне не рекомендуется хранить в них какую либо `sensitive data` (passwords, payment credentials, etc...)__

### Роль рефреш токенов и зачем их хранить в БД ?
Рефреш на сервере хранится для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять(кому позволено авторизоваться). Если не хранить рефреш токен в БД то велика вероятность того что токены будут бесконтрольно гулять по рукам злоумышленников. Для отслеживания которых нам придется заводить черный список и периодически чистить его от просроченных. В место этого мы храним лимитированный список белых токенов для каждого юзера отдельно и в случае кражи у нас уже есть механизм противодействия(описано ниже).

## Как ставить куки ?
Для того что бы `refreshToken` кука была успешно уставленна и отправлена браузером, адреса эндпоинтов аутентификации(`/api/auth/login`, `/api/auth/refresh-tokens`, `/api/auth/logout`) должны располагася в доменном пространстве сайта. Тоесть для домена `super.com` на сервере ставим куку с такими опциями:
```
{
    domain: '.super.com',
    path: '/api/auth'
}
```

Таким образом кука установится в браузер и прийдет на все эндпоинты по адресу `super.com/api/auth/<any-path>`

Если у нас монолит и за аутентификацию отвечает один и тот-же API, тут проблем не должно быть. Но если за аутентификацию отвечает отдельный микросервис, прячем его средствами `nginx` по выше указанному пути (`super.com/api/auth`).
```
# пример настройки nginx конфига(только основые настройки)
server {
    listen 80;
    server_name super.com;
    # SPA/Front-end
    location / {
        try_files $uri /index.html;
        root /var/www/frontend/dist;
        index index.html;
    }
    # Main API
    location /api {
        proxy_pass http://111.111.111.111:7000;
    }
    # Auth API
    location /api/auth {
        proxy_redirect http://222.222.222.222:7000   /auth/;
        proxy_pass http://222.222.222.222:7000;
    }
}
```

## Логин, создание сессии/токенов (api/auth/login):
1. Пользователь логинится в приложении, передавая логин/пароль и __fingerprint__ браузера (ну или некий иной уникальный идентификатор устройства если это не браузер)
2. Сервер проверят подлинность логина/пароля 
3. В случае удачи создает и записывает сессию в БД `{ userId: uuid, refreshToken: uuid, expiresIn: int, fingerprint: string, ... }` (схема таблицы ниже)
4. Создает __access token__
5. Отправляет клиенту __access и refresh token uuid__ (взятый из выше созданной сессии)
```
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly // для браузера
{
  body: { 
    accessToken: 'eyJhbGciOiJIUzUxMiIsI...',
    refreshToken: 'c84f18a2-c6c7-4850-be15-93f9cbaef3b3' // для мобильных приложений
  }
}
```
6. Клиент сохраняет токены(__access__ в памяти приложения, __refresh__  сетится как кука автоматом)

На что нужно обратить внимание при установке __refresh__ куки:
- `maxAge` куки ставим равную `expiresIn` из выше созданной сессии
- В `path` ставим корневой роут `auth` контроллера  (`/api/auth`) это важно, таким образом токен получат только те хендлеры которым он нужен(`/api/auth/logout` и `/api/auth/rerfesh-tokens`), остальные обойдутся(нечего зря почём отправлять __sensitive data__).

__Стоит заметить, что процесс добавления сессии в таблицу должен имеет свои меры безопасности.__ При добавлении стоит проверять сколько рефреш-сессий всего есть у юзера и, если их слишком много или юзер конектится одновременно из нескольких подсетей, стоит предпринять меры. Имплементируя данную проверку, я проверяю только что бы юзер имел максимум до 5 одновременных рефреш-сессий максимум, и при попытке установить следующую удаляю предыдущие. Все остальные проверки на ваше усмотрение в зависимости от задачи.

Таким образом если юзер залогинился на пяти устройствах, рефреш токены будут постоянно обновляться и все счастливы. Но если с аккаунтом юзера начнут производить подозрительные действия(попытаются залогинится более чем на 5'ти устройствах) система сбросит все сессии(рефреш токены) кроме последней.

Перед каждым запросом клиент предварительно проверяет время жизни __access token'а__ (да берем `expiresIn` прямо из JWT в клиентском приложении) и если оно истекло  шлет запрос на обновление токенов. Для большей уверенности можем обновлять токены на несколько секунд раньше. То есть кейс когда API получит истекший __access__ токен практически исключен.

Что такое __fingerprint__ ? Это инструмент отслеживания браузера вне зависимости от желания пользователя быть идентифицированным. Это хеш сгенерированный js'ом на базе неких уникальных параметров/компонентов браузера. Преимущество __fingerprint'a__ в том что он нигде персистентно не хранится и генерируется только в момент логина и рефреша.
- Библиотека для хеширования:  https://github.com/Valve/fingerprintjs2
- Более подробно:  https://player.vimeo.com/video/151208427
- Пример ф-ции получения такого хеша: https://gist.github.com/zmts/b26ba9a61aa0b93126fc6979e7338ca3

В случае если клиент не браузер, а мобильное приложение, в качестве __fingerprint__ используем любую уникальную строку(тот же `uuid`) персистентно хранящуюся на устройстве.

## Рефреш токенов (api/auth/refresh-tokens):
Для использования возможности аутентификации на более чем одном девайсе необходимо хранить все рефреш токены по каждому юзеру. Я храню это список в PostgreSQL таблице(а надо бы в Redis'е). В процессе каждого логина создается запись с IP/Fingerprint и другой мета информацией, так званая __рефреш-сессия__.
```
CREATE TABLE refreshSessions (
    "id" SERIAL PRIMARY KEY,
    "userId" uuid REFERENCES users(id) ON DELETE CASCADE,
    "refreshToken" uuid NOT NULL,
    "ua" character varying(200) NOT NULL, /* user-agent */
    "fingerprint" character varying(200) NOT NULL,
    "ip" character varying(15) NOT NULL,
    "expiresIn" bigint NOT NULL,
    "createdAt" timestamp with time zone NOT NULL DEFAULT now()
);
```

1. Клиент(фронтенд) проверяет перед запросом не истекло ли время жизни __access token'на__
2. Если истекло клиент делает запрос на `POST auth/refresh-tokens` `{ fingerprint: string }` в `body` и соответственно `refreshToken` куку.
3. Сервер получает запись рефреш-сессии по UUID'у рефреш токена
4. Сохраняет текущую рефреш-сессию в переменную и удаляет ее из таблицы
5. Проверяет текущую рефреш-сессию:
    1. Не истекло ли время жизни
    2. На соответствие старого  __fingerprint'a__ полученного из текущей рефреш-сессии с новым полученным из тела запроса
6. В случае негативного результата бросает ошибку `TOKEN_EXPIRED`/`INVALID_REFRESH_SESSION`
7. В случае успеха создает новую рефреш-сессию и записывает ее в БД
8. Создает __access token__
8. Отправляет клиенту __access и refresh token uuid__ (взятый из выше созданной рефреш-сессии)
```
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly // для браузера
{
  body: { 
    accessToken: 'eyJhbGciOiJIUzUxMiIsI...',
    refreshToken: 'c84f18a2-c6c7-4850-be15-93f9cbaef3b3' // для мобильных приложений
  }
}
```

_Tip:_ Для отправки запроса с куками для `axios` есть опция `{ withCredentials: true }`

## Ключевой момент:
В момент рефреша то есть обновления __access token'a__ обновляются __ОБА__ токена. Но как же __refresh token__ может сам себя обновить, он ведь создается только после успешной аутентификации ? __refresh token__ в момент рефреша сравнивает себя с тем __refresh token'ом__ который лежит в БД и вслучае успеха, а также если у него не истек срок, система рефрешит токены. 

Вопрос зачем __refresh token'y__ срок жизни, если он обновляется каждый раз при обновлении __access token'a__ ? Это сделано на случай, если юзер будет в офлайне более 60 дней, тогда придется заново вбить логин/пароль.

## Logout (api/auth/logout)
1. Front-end делает кол `POST: api/auth/logout` c __refreshToken__ в куке или бади (лучше в куки)
2. Front-end удаляет локально сохраненный в памяти __accessToken__
3. Back-end удаляет запись из таблицы `refreshSessions` по __refreshToken__

__accessToken__ умирает по истечению строка его жизни. Руками банить, удалять, хранить __accessToken__ не нужно, это нарушает всю суть эксесс токена.

## В случае кражи access токена и refresh куки:
1. Хакер воспользовался __access token'ом__
2. Закончилось время жизни __access token'на__
3. __Клиент хакера__ отправляет __refresh token__ и __fingerprint__
4. Сервер смотрит __fingerprint__ хакера
5. Сервер не находит __fingerprint__ хакера в рефреш-сессии и удаляет ее из БД
6. Сервер логирует попытку несанкционированного обновления токенов
7. Сервер перенаправляет хакера на станицу логина. Хакер идет лесом
8. Юзер пробует зайти на сервер >> обнаруживается что __refresh token__ отсутствует
9. Сервер перенаправляет юзера на форму аутентификации
10. Юзер вводит логин/пароль

## В случае кражи access токена, refresh куки и fingerprint'а:
Стащить все авторизационные данные это не из легких задач, но все же допустим этот кейс как крайний и наиболее неудобный с точки зрения UX (без примера в кодовой базе `supra-api-nodejs`).

Предложу несколько вариантов решения данной проблемы:

- Хранить IP или Subnet залогиненного клиента
1. Хакер воспользовался __access token'ом__
2. Закончилось время жизни __access token'на__
3. __Хакер__ отправляет __refresh__ куку и __fingerprint__
4. Сервер проверяет IP __хакера__, __хакер__ идет лесом

_UX минус: нужно логинится с каждого нового IP._

- Удалять все сессии в случае если __refresh__ токен не найден
1. Хакер воспользовался __access token'ом__
2. Закончилось время жизни __access token'на__
3. __Хакер__ отправляет __refresh__ куку и __fingerprint__
4. На сервере создается новый __refresh__ токен ("от хакера")
5. Хакер получает новую пару токенов
6. Юзер пробует отправить запрос на сервер >> обнаруживается что __refresh__ токен не валиден
7. Сервер удаляет все сессии юзера, в последствии чего хакер больше не сможет обновлять __access__ токен
8. Сервер создает новую сессию для пользователя

_UX минус: в каждом случае когда сервер не будет находить рефреш токен - будут сбрасиватся все сессии юзера на всех устройствах._

## Зачем все это ? JWT vs Cookie sessions
Зачем этот весь геморой ? Почему не юзать старые добрые cookie sessions ? Чем не угодили куки ?
- Куки подвержены CSRF: https://habr.com/ru/company/oleg-bunin/blog/412855 https://www.youtube.com/watch?v=x5AuK_IbJlg
- Нативыным приложениям для сматфонов удобнее работать с токенами. Да есть хаки для работы с куки, но это не нативная поддержка
- Куки в микросерисной архитектуре использовать не вариант. Напомню зачастую микросервисы раскиданы на разных доменах, а куки не поддерживают кросc-доменные запросы
- В микросерисной архитектуре JWT позволяет каждому сервису независимо от сервера авторизации верифицировать `access` токен (через публичный ключ)
- При использовании cookie sessions программист зачастую надеется на то, что предоставил фреймворк и оставляет как есть
- При использовании jwt мы видим проблему с безопасностью и стараемся предусмотреть механизмы контроля в случае каржи авторизационных данных. При использовании cookie сессий программист зачастую даже не задумывается что сессия может быть скомпрометирована
- __На каждом запросе__ использование JWT избавляет бекенд от одного запроса в БД(или кеш) за данными пользователя(`userId`, `email`, etc.)

## В итоге:
- __access__ токены храним исключительно в памяти клиентского приложения. Не в глобально доступной переменной аля `window.accessToken` а в __замыкании__
- __refresh__ токен храним исключительно в __httpOnly__ куке
- Механизмы контроля при угоне __sensitive data__ в наличии
- Взяли лучшее из обеих технологий, максимально обезопасились от CSRF/XSS
- Добавьте в компанию ко всему CSP заголовки и SameSite=Strict флаг для кук и ждите прихода злодеев

p.s. Каждой задаче свой подход. Юзайте в небольших/средних монолитах `cookie sessions` и не парьтесь. Ну или на ваш вкус :) 

___
### Имплементация:
__Front-end:__
- https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/http.init.js
- https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/auth.service.js

__Back-end:__
- https://github.com/zmts/supra-api-nodejs/tree/master/modules/auth

### Info:
- https://www.youtube.com/playlist?list=PLvTBThJr861y60LQrUGpJNPu3Nt2EeQsP
- https://habrahabr.ru/company/Voximplant/blog/323160/
- https://tools.ietf.org/html/rfc6749
- https://www.digitalocean.com/community/tutorials/oauth-2-ru
- https://jwt.io/introduction/
- https://auth0.com/blog/using-json-web-tokens-as-api-keys/
- https://auth0.com/blog/cookies-vs-tokens-definitive-guide/
- https://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/
- https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/
- https://habr.com/company/dataart/blog/262817/
- https://habr.com/post/340146/
- https://habr.com/company/mailru/blog/115163/
- https://scotch.io/tutorials/authenticate-a-node-js-api-with-json-web-tokens
- https://egghead.io/courses/json-web-token-jwt-authentication-with-node-js
- https://www.digitalocean.com/community/tutorials/oauth-2-ru
- https://github.com/shieldfy/API-Security-Checklist/blob/master/README-ru.md
- https://www.youtube.com/watch?v=Ngh3KZcGNaU
- https://www.youtube.com/watch?v=R0-eoLp871s
- https://www.youtube.com/watch?v=u9hn3s2kUrg
- https://ain.ua/2020/02/29/adtech-bez-cookies/
- https://habr.com/ru/post/492830 (cookies SameSite)

### And why JWT is bad
- http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
- http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
- https://medium.com/@cjainn/anatomy-of-a-jwt-token-part-1-8f7616113c14
- https://medium.com/@cjainn/anatomy-of-a-jwt-token-part-2-c12888abc1a2
- https://scotch.io/bar-talk/why-jwts-suck-as-session-tokens
- https://t.me/why_jwt_is_bad

```
import pytest
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager


LINK_INVALID_LOCATOR = (By.XPATH, '//*[@id="authorization_section"]/div/div/div[3]/form/div[1]/div[2]/span')


@pytest.fixture(scope="function")
def browser():
    """Фикстура для настройки WebDriver."""
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
    yield driver
    driver.quit()


@pytest.fixture(scope="function", params=[
    "podchasova11@yandex.ru",
    # " ",
    # "de",
    # " povq11@yandex"
])
def cur_login(request):
    """Фикстура для логина."""
    return request.param


@pytest.fixture(scope="function", params=[
    "Mila4114"
    # ".ru",
    # " ",
    # "de",
    # " povq11@yandex"
])
def cur_password(request):
    """Фикстура для пароля."""
    return request.param


# @pytest.mark.usefixtures("cur_login", "cur_password")
class TestLoginPage:
    """Класс для тестирования страницы входа."""
    flag_of_bug = False

    @staticmethod
    def pytest_fail(msg):
        TestLoginPage.flag_of_bug = True
        pytest.fail(msg)

    @pytest.mark.parametrize("cur_login", "cur_password")
    def test_login_redirect_and_input(self, browser, cur_login, cur_password):
        """Проверка перехода на страницу входа и ввода логина и пароля."""
        browser.get("https://preprod-ox7ia7ea.stroycode.ru/")

        # Ожидание загрузки страницы входа
        WebDriverWait(browser, 5).until(EC.presence_of_element_located((By.XPATH, "//*[@id='cookie-notice']/div/button")))

        # Принять куки, если возникает такое окно
        try:
            accept_cookies_button = WebDriverWait(browser, 5).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='cookie-notice']/div/button")))
            accept_cookies_button.click()
        except Exception as e:
            print("Кнопка принятия куки не найдена или не доступна:", e)

        # Переход на страницу регистрации
        next_page_button = WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//*[@id='registration']/div/div[2]/div[3]/a")))
        next_page_button.click()

        # Ввод логина и пароля
        email_input = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.XPATH, "//*[@id='authorization_section']/div/div/div[3]/form/div[1]/div/div/div[2]/div/input")))
        password_input = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.XPATH, "//*[@id='authorization_section']/div/div/div[3]/form/div[2]/div[1]/div/div/div[2]/div/input")))

        email_input.send_keys(cur_login)  # Ввод логина

        # Проверить логин
        if len(browser.find_elements(*LINK_INVALID_LOCATOR)) == 0:
            msg = f"Введен не валидный логин"
            print(f"Баг  => {msg}")
            TestLoginPage.pytest_fail(f"Bug # {msg}")
        print(f"Введен валидный логин\n")

        password_input.send_keys(cur_password)  # Ввод пароля

        # Проверить пароль

        # Клик на кнопку "Авторизоваться"
        submit_button = browser.find_element(By.XPATH, '//*[@id="authorization_section"]/div/div/div[3]/form/button')
        submit_button.click()

        time.sleep(5)

        # Проверка, произошел ли вход на страницу авторизации
        WebDriverWait(browser, 10).until(EC.url_contains("verify-email"))
        assert "verify-email" in browser.current_url, "Не удалось войти: текущий URL не содержит 'verify-email'"


if __name__ == "__main__":
    pytest.main()
```
_________________________
____________________________

В Python вы можете форматировать строки с помощью f-строк, а также с использованием оператора `%`. Оба метода имеют свои особенности. Вот основные способы их использования:

### 1. Форматирование с помощью f-строк

**f-строки** (введены в Python 3.6) — это удобный способ вставлять значения переменных прямо в строку. Если вам нужно вставить переменные в строку, вы можете сделать это, добавляя букву `f` перед строчной кавычкой и используя фигурные скобки `{}` для переменных.

```python
name = "Alice"
age = 30

formatted_string = f"My name is {name} and I am {age} years old."
print(formatted_string)  # Вывод: My name is Alice and I am 30 years old.
```

### 2. Форматирование с помощью оператора `%`

Форматирование строк с использованием оператора `%` также распространено, хотя этот метод считается устаревшим по сравнению с f-строками и методом `.format()`. Однако он все еще широко используется. Вот как это работает:

```python
name = "Alice"
age = 30

formatted_string = "My name is %s and I am %d years old." % (name, age)
print(formatted_string)  # Вывод: My name is Alice and I am 30 years old.
```

- `%s` — это заполнитель для строки.
- `%d` — это заполнитель для целого числа.

### 3. Использование форматирования с `.format()`

Хотя это не f-строки или `%`, метод `.format()` также стоит упомянуть, поскольку он более гибкий и читаемый:

```python
name = "Alice"
age = 30

formatted_string = "My name is {} and I am {} years old.".format(name, age)
print(formatted_string)  # Вывод: My name is Alice and I am 30 years old.
```


### Заключение

Используйте f-строки для более современного и удобного форматирования строк. Тем не менее, знание других методов, таких как `%` и `.format()`, полезно, особенно если вы работаете с устаревшим кодом. 
________________________________________________

Давайте рассмотрим ваш код: 

```python
a = [[]] *
a[0][0] = 'abc'
```

### Объяснение кода

1. **Инициализация `a`**:
   - Код `a = [[]] * n` создает список `a` из `n` (в этом случае `1`) ссылки на один и тот же внутренний список. Это означает, что все подсписки в `a` являются ссылками на один и тот же объект в памяти.

2. **Обращение к элементу**:
   - Когда вы выполняете `a[0][0] = 'abc'`, вы пытаетесь присвоить значение `'abc'` первому элементу первого подсписка.

### Проблема

Вот в чем проблема: если ваш код `a` неправильно сработает из-за некорректного присвоения. Ваша инициализация `a` фактически будет выглядеть как:

```python
a = [[]] * 1  # Это означает, что a = [[]], где [0] ссылается на один и тот же список
```

При попытке присвоить значение `'abc'` в `a[0][0]` возникнет ошибка, так как подсписок `[]` изначально пуст, и вы не сможете получить доступ к индексу `[0]` до его инициализации значением.

### Исправление кода

Чтобы правильно инициализировать список и избежать ошибки, вы можете использовать следующее:

```python
# Правильная инициализация с созданием независимого элемента
a = [[]]  # Создаем один подсписок
a[0].append('abc')  # Добавляем 'abc' в подсписок

# Результат
print(a)  # Вывод: [['abc']]
```

### Итоги
Таким образом, правильный подход — это сначала создавать подсписки, а затем добавлять элементы в них с помощью метода `.append()`. 

_______________________________________
Давайте внимательно рассмотрим ваш код:

```python
a = [[1, 2, 3]] * 3
a[0][0] = 'abc'
```

### Шаги выполнения

1. **Инициализация `a`**:
   - Строка `a = [[1, 2, 3]] * 3` создает список `a`, состоящий из трех ссылок на один и тот же внутренний список `[1, 2, 3]`.
   - На практике, это означает, что `a` становится:
     ```python
     a = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
     ```
   - Все элементы списка `a` ссылаются на один и тот же объект в памяти.

2. **Присвоение `a[0][0] = 'abc'`**:
   - Сначала вы обращаетесь к первому элементу первого подсписка `a[0][0]`, который равен `1`.
   - Затем вы присваиваете `'abc'` этому элементу. Однако, поскольку все подсписки в `a` являются ссылками на один и тот же объект, изменение `a[0][0]` также изменяет `a[1][0]` и `a[2][0]`.

### Результат выполнения кода

После выполнения кода в конце, структура `a` будет следующей:

```python
a = [['abc', 2, 3], ['abc', 2, 3], ['abc', 2, 3]]
```

### Проверка результата

Чтобы увидеть это в действии, вы можете проверить:

```python
print(a)  # Вывод: [['abc', 2, 3], ['abc', 2, 3], ['abc', 2, 3]]
```

### Заключение

Итак, результатом будет, что все подсписки в `a` изменены, так как они все ссылаются на один и тот же объект. Если вам нужно создать независимые подсписки, вы должны использовать другой подход, например:

```python
a = [[1, 2, 3] for _ in range(3)]
```

Это создаст три отдельных подсписка, и изменения в одном не отразятся на других.
_______________________________________________________

В вашем коде есть ошибка, которую стоит разобрать:

```python
a = [1, 2, 3] * 3   
a[0][0] = 'abc'
```

### Шаги выполнения кода

1. **Инициализация `a`**:
   - Строка `a = [1, 2, 3] * 3` создает список `a`, который содержит три элемента `[1, 2, 3]`. Таким образом, значение `a` будет равным:
     ```python
     a = [1, 2, 3, 1, 2, 3, 1, 2, 3]
     ```

2. **Обращение к элементу `a[0][0]`**:
   - Ваша следующая строка `a[0][0] = 'abc'` пытается обратиться к `a[0][0]`. 
   - Однако, `a[0]` (то есть, первый элемент списка `a`) равно **1** (это целое число).

### Почему это ошибка

Поскольку `1` — это целое число, которое **не является списком**, в результате вы получите ошибку типа `TypeError: 'int' object is not subscriptable`, так как вы пытаетесь индексировать число, а не список.

### Решение проблемы

Если вы хотите создать список списков и затем изменить один из его элементов, вы можете инициализировать его следующим образом:

```python
# Правильная инициализация с помощью list comprehension
a = [[1, 2, 3] for _ in range(3)]
a[0][0] = 'abc'

# Проверка результата
print(a)  # Вывод: [['abc', 2, 3], [1, 2, 3], [1, 2, 3]]
```

### Вывод

В этом примере мы создаем список `a`, состоящий из трех отдельных списков, и вы сможете успешно изменить `a[0][0]` на `'abc'`.
_________________________

Разберём ваш код:

```python
a = [[1, 2, 3] for _ in range(3)]
```

### Объяснение каждого элемента кода

1. **`[1, 2, 3]`**:
   - Это обычный список, содержащий три элемента: `1`, `2` и `3`.

2. **`for _ in range(3)`**:
   - Это цикл, который будет выполняться 3 раза. Функция `range(3)` генерирует последовательность из трёх чисел: `0`, `1`, `2`. Переменная `_` часто используется в Python, когда значение переменной не нужно, что делает код более читабельным (показывает, что значение переменной не будет использоваться).

3. **`[[1, 2, 3] for _ in range(3)]`**:
   - Это **генератор списков** (list comprehension), который создает новый список, выполняя выражение `[1, 2, 3]` для каждого элемента, генерируемого `for _ in range(3)`.
   - В результате мы получим три независимых списка `[1, 2, 3]`, созданных в каждой итерации.

### Результат выполнения

После выполнения этого кода переменная `a` будет содержать:

```python
a = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

### Ключевые моменты

- **Независимые списки**: Каждая подгруппа `[1, 2, 3]` — это отдельный список в памяти. Это означает, что изменения в одном из этих подсписков не повлияют на остальные.
  
  Например:
  ```python
  a[0][0] = 'abc'
  print(a)  # Вывод: [['abc', 2, 3], [1, 2, 3], [1, 2, 3]]
  ```

### Сравнение с `a = [[1, 2, 3]] * 3`

В отличие от этого подхода, если вы использовали `a = [[1, 2, 3]] * 3`, все подсписки ссылаются на один и тот же объект. Изменения в одном подсписке повлияют на все:

```python
a = [[1, 2, 3]] * 3
a[0][0] = 'abc'
print(a)  # Вывод: [['abc', 2, 3], ['abc', 2, 3], ['abc', 2, 3]]
```

### Заключение

Код `a = [[1, 2, 3] for _ in range(3)]` — это удобный способ создать многомерный список с независимыми подсписками.
